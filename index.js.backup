require('dotenv').config({
  path: process.env.NODE_ENV === 'production' ? '.env.production' : '.env'
});

const express = require('express');
const session = require('express-session');
const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;
const multer = require('multer');
const cors = require('cors');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const fs = require('fs');
const path = require('path');
const { google } = require('googleapis');
const mongoose = require('mongoose');
const MongoStore = require('connect-mongo');

// Import models
const User = require('./models/User');
const ChatHistory = require('./models/ChatHistory');
const ActionHistory = require('./models/ActionHistory');
const ChangePlan = require('./models/ChangePlan');

const app = express();
const PORT = process.env.PORT || 3001;

// MongoDB Connection
const mongoUri = process.env.MONGODB_URI || 'mongodb://localhost:27017/fin-copilot';
console.log('ğŸ”— Attempting to connect to MongoDB...');
console.log('ğŸ”— Database URI:', mongoUri.replace(/:[^:@]*@/, ':***@')); // Hide password in logs

mongoose.connect(mongoUri, {
  serverSelectionTimeoutMS: 10000 // Timeout after 10s instead of 30s
})
.then(() => {
  console.log('ğŸƒ Connected to MongoDB successfully');
  console.log('ğŸ“Š Database name:', mongoose.connection.db.databaseName);
  
  // Test the connection by listing collections
  mongoose.connection.db.listCollections().toArray()
    .then(collections => {
      console.log('ğŸ“ Available collections:', collections.map(c => c.name));
    })
    .catch(err => console.log('âš ï¸  Could not list collections:', err.message));
})
.catch((error) => {
  console.error('âŒ MongoDB connection error:', error.message);
  console.log('ğŸ’¡ Check your Azure Cosmos DB connection string and credentials');
  
  // Don't exit in development so you can still test other features
  if (process.env.NODE_ENV === 'production') {
    process.exit(1);
  }
});

// Monitor connection events
mongoose.connection.on('connected', () => {
  console.log('ğŸ“¡ Mongoose connected to MongoDB');
});

mongoose.connection.on('error', (err) => {
  console.error('ğŸ“¡ Mongoose connection error:', err);
});

mongoose.connection.on('disconnected', () => {
  console.log('ğŸ“¡ Mongoose disconnected from MongoDB');
});

// Initialize Gemini AI
const key = "AIzaSyC83AY7WDibXU0cgttKO4vQoPh1WrtcS0E";
console.log("ğŸ”‘ Initializing Gemini with API Key:", key ? `${key.substring(0, 4)}...${key.substring(key.length - 4)}` : 'No key found!');
const genAI = new GoogleGenerativeAI(key);

// ActionHistory model is now used instead of in-memory pendingChanges

// ğŸ“¸ Helper Functions for Change Management
function cellToRange(cellAddress, sheetId) {
    const match = cellAddress.match(/([A-Z]+)(\d+)/);
    const column = match[1];
    const row = parseInt(match[2]);
    
    return {
        sheetId: sheetId,
        startRowIndex: row - 1,
        endRowIndex: row,
        startColumnIndex: column.charCodeAt(0) - 'A'.charCodeAt(0),
        endColumnIndex: column.charCodeAt(0) - 'A'.charCodeAt(0) + 1
    };
}

async function takeSnapshot(cellAddresses, sheets, spreadsheetId, selectedSheetName, sheetId) {
    console.log(`ğŸ“¸ Taking snapshot of ${cellAddresses.length} cells before changes`);
    
    const CHUNK_SIZE = 50; // ××’×‘×™×œ ×œ-50 ×ª××™× ×œ×›×œ ×‘×§×©×”
    const snapshot = {};
    
    // ×—×™×œ×•×§ ×”×ª××™× ×œ-chunks
    for (let i = 0; i < cellAddresses.length; i += CHUNK_SIZE) {
        const chunk = cellAddresses.slice(i, i + CHUNK_SIZE);
        const ranges = chunk.map(cell => `${selectedSheetName}!${cell}`);
        
        // ×§×¨× values ×¢×‘×•×¨ ×”-chunk ×”×–×”
        const valuesResponse = await sheets.spreadsheets.values.batchGet({
            spreadsheetId: spreadsheetId,
            ranges: ranges
        });
        
        // ×§×¨× formatting ×¢×‘×•×¨ ×”-chunk ×”×–×”
        const sheetData = await sheets.spreadsheets.get({
            spreadsheetId: spreadsheetId,
            ranges: ranges,
            includeGridData: true
        });
        
        // ×¢×‘×“ ××ª ×”-chunk
        chunk.forEach((cellAddress, index) => {
            // Get the value
            const valueRange = valuesResponse.data.valueRanges[index];
            const value = valueRange.values?.[0]?.[0] || "";
            
            // Get the formatting
            const cellData = extractCellFormatting(sheetData, cellAddress, selectedSheetName);
            
            snapshot[cellAddress] = {
                value: value,
                backgroundColor: cellData.backgroundColor || { red: 1, green: 1, blue: 1 },
                textFormat: cellData.textFormat || {},
                numberFormat: cellData.numberFormat || {}
            };
        });
    }
    
    console.log(`ğŸ“¸ Snapshot captured:`, Object.keys(snapshot));
    return snapshot;
}

function extractCellFormatting(sheetData, cellAddress, sheetName) {
    try {
        const match = cellAddress.match(/([A-Z]+)(\d+)/);
        const column = match[1];
        const row = parseInt(match[2]) - 1; // Convert to 0-based
        const colIndex = column.charCodeAt(0) - 'A'.charCodeAt(0);
        
        const sheet = sheetData.data.sheets.find(s => s.properties.title === sheetName);
        if (!sheet || !sheet.data || !sheet.data[0] || !sheet.data[0].rowData) {
            return {};
        }
        
        const rowData = sheet.data[0].rowData[row];
        if (!rowData || !rowData.values || !rowData.values[colIndex]) {
            return {};
        }
        
        const cellData = rowData.values[colIndex];
        return {
            backgroundColor: cellData.userEnteredFormat?.backgroundColor,
            textFormat: cellData.userEnteredFormat?.textFormat,
            numberFormat: cellData.userEnteredFormat?.numberFormat
        };
    } catch (error) {
        console.error('Error extracting cell formatting:', error);
        return {};
    }
}

// Create uploads directory if it doesn't exist
const uploadsDir = path.join(__dirname, 'uploads');
if (!fs.existsSync(uploadsDir)) {
    fs.mkdirSync(uploadsDir);
}

// Configure multer for file uploads
const upload = multer({ 
  storage: multer.memoryStorage(),
  limits: { fileSize: 50 * 1024 * 1024 } // 50MB limit
});

// Configure CORS
const corsOptions = {
  origin: process.env.NODE_ENV === 'production'
    ? process.env.FRONTEND_URL
    : 'http://localhost:3000',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
};

app.use(cors(corsOptions));
app.use(express.json());

app.use(session({
    secret: process.env.SESSION_SECRET || 'your-session-secret',
    resave: false,
    saveUninitialized: false,
    store: MongoStore.create({
        mongoUrl: mongoUri,
        touchAfter: 24 * 3600 // lazy session update
    }),
    cookie: {
        maxAge: 24 * 60 * 60 * 1000, // 24 hours
        secure: process.env.NODE_ENV === 'production',
        httpOnly: true
    }
}));

app.use(passport.initialize());
app.use(passport.session());

passport.serializeUser((user, done) => done(null, user._id));
passport.deserializeUser(async (id, done) => {
    try {
        const user = await User.findById(id);
        done(null, user);
    } catch (error) {
        done(error, null);
    }
});

passport.use(new GoogleStrategy({
    clientID: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    callbackURL: "/auth/google/callback"
}, async (accessToken, refreshToken, profile, done) => {
    try {
        console.log('ğŸ” Google OAuth callback - Profile:', {
            id: profile.id,
            name: profile.displayName,
            email: profile.emails[0].value
        });

        // Check if user already exists
        let user = await User.findOne({ googleId: profile.id });
        
        if (user) {
            // Update existing user
            user.accessToken = accessToken;
            user.refreshToken = refreshToken;
            user.lastLogin = new Date();
            user.name = profile.displayName; // Update name in case it changed
            user.email = profile.emails[0].value; // Update email
            if (profile.photos && profile.photos.length > 0) {
                user.profilePicture = profile.photos[0].value;
            }
            await user.save();
            console.log('ğŸ‘¤ Updated existing user:', user.email);
        } else {
            // Create new user
            user = new User({
                googleId: profile.id,
                email: profile.emails[0].value,
                name: profile.displayName,
                profilePicture: profile.photos && profile.photos.length > 0 ? profile.photos[0].value : null,
                accessToken: accessToken,
                refreshToken: refreshToken
            });
            await user.save();
            console.log('ğŸ†• Created new user:', user.email);
        }
        
        return done(null, user);
    } catch (error) {
        console.error('âŒ Error in Google OAuth strategy:', error);
        return done(error, null);
    }
}));

app.get('/', (req, res) => {
    if (req.isAuthenticated()) {
        res.redirect('http://localhost:3000');
    } else {
        const html = `<!DOCTYPE html>
<html dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>×”×ª×—×‘×¨×•×ª - Fin-Copilot</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', 'Segoe UI', sans-serif;
            background: #000000;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            direction: rtl;
            overflow: hidden;
        }
        .background-animation {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 20% 80%, #8B5CF6 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, #6366F1 0%, transparent 50%),
                        radial-gradient(circle at 40% 40%, #7C3AED 0%, transparent 50%);
            animation: pulse 4s ease-in-out infinite alternate;
        }
        @keyframes pulse { 0% { opacity: 0.3; } 100% { opacity: 0.6; } }
        .container {
            position: relative;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(139, 92, 246, 0.2);
            padding: 3rem;
            border-radius: 24px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(139, 92, 246, 0.1);
            text-align: center;
            max-width: 420px;
            width: 90%;
            z-index: 1;
        }
        .logo {
            font-size: 2.8rem;
            font-weight: 700;
            background: linear-gradient(135deg, #8B5CF6 0%, #6366F1 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
            letter-spacing: -0.02em;
        }
        .subtitle {
            color: #A78BFA;
            margin-bottom: 3rem;
            font-size: 1.1rem;
            font-weight: 400;
            opacity: 0.9;
        }
        .google-btn {
            position: relative;
            background: linear-gradient(135deg, #8B5CF6 0%, #6366F1 100%);
            color: white;
            border: none;
            padding: 1.2rem 2rem;
            border-radius: 16px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            width: 100%;
            text-decoration: none;
            font-family: 'Inter', sans-serif;
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3);
            overflow: hidden;
        }
        .google-btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        .google-btn:hover::before { left: 100%; }
        .google-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.4);
        }
        .google-btn:active { transform: translateY(0); }
        .google-icon {
            width: 24px; height: 24px;
            background: white;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: #4285f4;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .features {
            margin-top: 2.5rem;
            text-align: right;
        }
        .feature {
            margin: 0.75rem 0;
            color: #818CF8;
            font-size: 0.95rem;
            font-weight: 400;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            opacity: 0.9;
        }
        .feature::before {
            content: "âœ“";
            color: #8B5CF6;
            font-weight: 600;
            margin-left: 0.75rem;
            font-size: 1.1rem;
        }
        .loading {
            display: none;
            margin-top: 1.5rem;
            color: #A78BFA;
        }
        .spinner {
            border: 2px solid rgba(139, 92, 246, 0.2);
            border-top: 2px solid #8B5CF6;
            border-radius: 50%;
            width: 24px; height: 24px;
            animation: spin 1s linear infinite;
            margin: 0 auto 0.5rem;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .powered-by {
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid rgba(139, 92, 246, 0.1);
            color: #6B7280;
            font-size: 0.85rem;
            font-weight: 400;
        }
        @media (max-width: 480px) {
            .container { padding: 2rem; margin: 1rem; }
            .logo { font-size: 2.2rem; }
            .subtitle { font-size: 1rem; }
        }
    </style>
</head>
<body>
    <div class="background-animation"></div>
    <div class="container">
        <div class="logo">Fin-Copilot</div>
        <div class="subtitle">×¢×•×–×¨ AI ×¤×™× × ×¡×™ ××ª×§×“×</div>
        
        <a href="/auth/google" class="google-btn" onclick="showLoading()">
            <div class="google-icon">G</div>
            ×”×ª×—×‘×¨ ×¢× Google
        </a>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>××ª×—×‘×¨ ×œ×—×©×‘×•×Ÿ Google...</p>
        </div>
        
        <div class="features">
            <div class="feature">×’×™×©×” ×××•×‘×˜×—×ª ×œ×’×œ×™×•× ×•×ª ×©×œ×š</div>
            <div class="feature">×¢×¨×™×›×” ×‘×–××Ÿ ×××ª ×¢× AI</div>
            <div class="feature">× ×™×ª×•×— × ×ª×•× ×™× ××ª×§×“×</div>
            <div class="feature">×××©×§ ××©×ª××© ××•×“×¨× ×™</div>
        </div>
        
        <div class="powered-by">
            ××•×¤×¢×œ ×¢×œ ×™×“×™ Google OAuth 2.0
        </div>
    </div>
    
    <script>
        function showLoading() {
            document.querySelector('.google-btn').style.display = 'none';
            document.getElementById('loading').style.display = 'block';
        }
        
        document.addEventListener('mousemove', (e) => {
            const container = document.querySelector('.container');
            const x = (e.clientX / window.innerWidth) * 100;
            const y = (e.clientY / window.innerHeight) * 100;
            container.style.transform = 'translate(' + (x * 0.02) + 'px, ' + (y * 0.02) + 'px)';
        });
    </script>
</body>
</html>`;
        res.send(html);
    }
});

app.get('/auth/google', passport.authenticate('google', { 
    scope: ['profile', 'email', 'https://www.googleapis.com/auth/spreadsheets', 'https://www.googleapis.com/auth/drive.readonly'] 
}));

app.get('/auth/google/callback',
    passport.authenticate('google', { failureRedirect: '/' }),
    (req, res) => {
        console.log('ğŸ” Google OAuth callback successful');
        console.log('ğŸ‘¤ User authenticated:', req.user.email);
        
        const token = req.user.accessToken;
        const redirectUrl = process.env.NODE_ENV === 'production'
            ? `${process.env.FRONTEND_URL}?token=${token}`
            : `http://localhost:3000?token=${token}`;
            
        res.redirect(redirectUrl);
    }
);

// Logout endpoint
app.get('/auth/logout', (req, res) => {
    req.logout((err) => {
        if (err) {
            console.error('Logout error:', err);
            return res.status(500).json({ error: 'Failed to logout' });
        }
        req.session.destroy((err) => {
            if (err) {
                console.error('Session destroy error:', err);
                return res.status(500).json({ error: 'Failed to destroy session' });
            }
            res.clearCookie('connect.sid'); // Clear the session cookie
            res.json({ message: 'Logged out successfully' });
        });
    });
});

app.get('/api/user', (req, res) => {
    if (req.isAuthenticated()) {
        res.json({
            user: {
                id: req.user._id,
                googleId: req.user.googleId,
                name: req.user.name,
                email: req.user.email,
                profilePicture: req.user.profilePicture,
                preferences: req.user.preferences,
                lastLogin: req.user.lastLogin
            },
            accessToken: req.user.accessToken
        });
    } else {
        res.status(401).json({ error: 'Not authenticated' });
    }
});

/**
 * Act I: The Backend Heist
 * This endpoint extracts numerical data and tables from a PDF and returns it as clean JSON.
 */
app.post('/api/extract-pdf-data', upload.single('pdf'), async (req, res) => {
    if (!req.file) {
        return res.status(400).json({ error: 'No file uploaded.' });
    }

    // Check file size (max 20MB for Gemini API)
    const maxSize = 20 * 1024 * 1024; // 20MB
    if (req.file.size > maxSize) {
        return res.status(400).json({ 
            error: `File too large. Maximum size is ${maxSize / (1024 * 1024)}MB, but received ${(req.file.size / (1024 * 1024)).toFixed(2)}MB.` 
        });
    }

    console.log(`[${new Date().toISOString()}] Starting data extraction for: ${req.file.originalname}`);

    // ğŸ”¥ ×§×‘×œ ×§×•× ×˜×§×¡×˜ ×”×’×œ×™×•×Ÿ ××”-FormData
    const sheetInstructions = req.body.sheetInstructions;
    const sheetAnalysis = req.body.sheetAnalysis; 
    const sheetName = req.body.sheetName;
    const sheetData = req.body.sheetData ? JSON.parse(req.body.sheetData) : null;
    
    console.log('ğŸ”¥ Sheet context received:', {
        hasInstructions: !!sheetInstructions,
        hasAnalysis: !!sheetAnalysis,
        sheetName: sheetName,
        hasSheetData: !!sheetData,
        sheetDataSize: sheetData ? sheetData.length : 0
    });

    // ğŸ”¥ NEW LOGIC: Check if we have sheet context for structured extraction
    const hasSheetContext = !!(sheetData && (sheetInstructions || sheetAnalysis));
    console.log(`[${new Date().toISOString()}] PDF processing mode: ${hasSheetContext ? 'STRUCTURED_EXTRACTION' : 'SIMPLE_OCR_WITH_CACHE'}`);

    try {
        if (hasSheetContext) {
            // === STRUCTURED EXTRACTION MODE (with sheet context) ===
            console.log(`[${new Date().toISOString()}] Using structured extraction with sheet context`);
            
            const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

            const pdfPart = {
                inlineData: {
                    data: req.file.buffer.toString("base64"),
                    mimeType: "application/pdf"
                }
            };

            console.log(`[${new Date().toISOString()}] PDF size: ${req.file.size} bytes`);

            // ×©×œ×‘×™×: 1) ×—×™×œ×•×¥ × ×ª×•× ×™×, 2) × ×™×ª×•×— ×”×ª×××” ×¤× ×™××™
            const extractionPrompt = `
You are an expert financial data analyst. Your task is to extract all relevant financial data from the provided PDF and provide an internal integration analysis.

**COMPLETE SHEET DATA:**
Here is the complete current sheet structure with all data, formulas, and layout:
\`\`\`json
${JSON.stringify(sheetData, null, 2)}
\`\`\`

${sheetInstructions ? `
**SHEET CONTEXT AVAILABLE:**
You are working with a financial model sheet that has specific requirements. Here are the instructions from the sheet analysis:

${sheetInstructions}

Based on this context, please focus on extracting the specific financial data mentioned in the "×—×™×œ×•×¥ ×-PDF" (PDF extraction) section above. Pay special attention to the data types, time periods, and specific metrics mentioned.
` : ''}

${sheetAnalysis ? `
**SHEET SUMMARY:**
This is what we know about the financial model you'll be updating:
${sheetAnalysis}

Extract data that is relevant to this type of financial model.
` : ''}

${sheetName ? `**Target Sheet:** ${sheetName}` : ''}

**YOUR DUAL TASK:**
1. **DATA EXTRACTION:** Extract financial data in a clear, structured text format
2. **INTEGRATION ANALYSIS (INTERNAL):** Provide detailed analysis of how this PDF data should integrate with the existing sheet

**EXTRACTION REQUIREMENTS:**
- Extract financial data in a clear, structured text format
- Include table headers and organize data logically
- Preserve context and relationships between data points
- Include units, time periods, and any important notes
- Focus on numerical data while keeping essential context
- Present data in a readable, organized manner (not as rigid JSON)
${sheetInstructions ? `
- Focus on the data types mentioned in the sheet instructions above
- Prioritize data that matches the financial model structure described
` : ''}

**INTEGRATION ANALYSIS REQUIREMENTS (INTERNAL - NOT FOR CLIENT):**
After extracting the data, provide a detailed step-by-step analysis addressing:
1. **Data Mapping:** Which PDF data corresponds to which existing sheet areas?
2. **Replacement vs. Addition:** Which data replaces existing values vs. adds new information?
3. **Table Expansion:** Do we need to expand existing tables? Where and how?
4. **Space Management:** Will new data require moving existing elements? What needs to be shifted?
5. **Partial Updates:** Does this report only cover specific sections of the model? Which ones?
6. **Integration Steps:** Detailed verbal steps for how to update the existing model with this new data
7. **Potential Conflicts:** Any areas where new data might conflict with existing formulas or structure?

**OUTPUT FORMAT:**
Return a JSON object with exactly two fields:
{
  "extractedData": "Clear, organized extracted data text here",
  "integrationAnalysis": "Detailed internal analysis of how this data integrates with the existing sheet structure, including step-by-step integration plan"
}
            `;

            // Retry mechanism for network failures
            let result;
            let attempts = 0;
            const maxAttempts = 3;
            
            while (attempts < maxAttempts) {
                try {
                    attempts++;
                    console.log(`[${new Date().toISOString()}] Attempt ${attempts}/${maxAttempts} to process PDF`);
                    
                    result = await model.generateContent({
                        contents: [{
                            role: "user",
                            parts: [pdfPart, { text: extractionPrompt }]
                        }]
                    });
                    break; // Success, exit retry loop
                    
                } catch (retryError) {
                    console.error(`[${new Date().toISOString()}] Attempt ${attempts} failed:`, retryError.message);
                    
                    if (attempts === maxAttempts) {
                        throw retryError; // Final attempt failed
                    }
                    
                    // Wait before retry (exponential backoff)
                    const waitTime = Math.pow(2, attempts) * 1000; // 2s, 4s, 8s
                    console.log(`[${new Date().toISOString()}] Waiting ${waitTime}ms before retry...`);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                }
            }

            const response = await result.response;
            const text = await response.text();
            
            console.log(`[${new Date().toISOString()}] Raw response from Gemini received.`);
            
            let extractedData, integrationAnalysis;
            
            // Try to parse as JSON
            try {
                // Clean JSON response more carefully
                const cleanedText = text
                    .replace(/```json/g, '')
                    .replace(/```/g, '')
                    .replace(/\n(?!["}])/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();

                const parsedResponse = JSON.parse(cleanedText);
                extractedData = parsedResponse.extractedData || text.trim();
                integrationAnalysis = parsedResponse.integrationAnalysis || null;
                
                console.log(`[${new Date().toISOString()}] Successfully parsed JSON response with integration analysis`);
            } catch (parseError) {
                console.log(`[${new Date().toISOString()}] Failed to parse JSON, using text as-is:`, parseError.message);
                extractedData = text.trim();
                integrationAnalysis = null;
            }
            
            console.log(`[${new Date().toISOString()}] Structured extraction successful for: ${req.file.originalname}`);
            
            // Save PDF file for later viewing
            const fileId = Date.now() + '_' + Math.random().toString(36).substring(2, 15);
            const filePath = path.join(__dirname, 'uploads', `${fileId}.pdf`);
            
            // Ensure uploads directory exists
            if (!fs.existsSync(path.join(__dirname, 'uploads'))) {
                fs.mkdirSync(path.join(__dirname, 'uploads'), { recursive: true });
            }
            
            fs.writeFileSync(filePath, req.file.buffer);
            console.log(`[${new Date().toISOString()}] PDF saved with fileId: ${fileId}`);
            
            // Return structured extraction results
            res.json({
                extractedText: extractedData,
                integrationAnalysis: integrationAnalysis,
                fileName: req.file.originalname,
                extractionDate: new Date().toISOString(),
                fileId: fileId,
                processingMode: 'structured',
                isFullText: false
            });
            
        } else {
            // === SIMPLE OCR MODE (no sheet context) - Use Gemini Caching ===
            console.log(`[${new Date().toISOString()}] Using simple OCR mode with Gemini caching`);
            
            // Create a temporary file for upload
            const fileId = Date.now() + '_' + Math.random().toString(36).substring(2, 15);
            const tempFilePath = path.join(__dirname, 'temp', `${fileId}.pdf`);
            
            // Ensure temp directory exists
            if (!fs.existsSync(path.join(__dirname, 'temp'))) {
                fs.mkdirSync(path.join(__dirname, 'temp'), { recursive: true });
            }
            
            fs.writeFileSync(tempFilePath, req.file.buffer);
            
            try {
                // Upload PDF to Gemini's file service using correct API
                console.log(`[${new Date().toISOString()}] Uploading PDF to Gemini file service...`);
                
                const uploadedDoc = await genAI.files.upload({
                    file: tempFilePath,
                    config: { mimeType: "application/pdf" }
                });
                
                console.log(`[${new Date().toISOString()}] PDF uploaded to Gemini: ${uploadedDoc.name}`);
                
                // Create cache with the uploaded PDF using correct API
                const modelName = "gemini-2.5-flash";
                const cache = await genAI.caches.create({
                    model: modelName,
                    config: {
                        contents: [
                            {
                                role: "user",
                                parts: [{ fileData: { mimeType: "application/pdf", fileUri: uploadedDoc.uri } }]
                            }
                        ],
                        systemInstruction: "You are a helpful assistant that can analyze and discuss the content of the provided PDF document. Answer questions about the document content clearly and accurately. The document is available for reference and analysis.",
                        ttl: "300s" // 5 minutes as requested
                    }
                });
                
                console.log(`[${new Date().toISOString()}] Cache created: ${cache.name}`);
                
                // Clean up temp file
                fs.unlinkSync(tempFilePath);
                
                // Save PDF for later viewing (optional)
                const savedFilePath = path.join(__dirname, 'uploads', `${fileId}.pdf`);
                if (!fs.existsSync(path.join(__dirname, 'uploads'))) {
                    fs.mkdirSync(path.join(__dirname, 'uploads'), { recursive: true });
                }
                fs.writeFileSync(savedFilePath, req.file.buffer);
                
                // Return cache information
                res.json({
                    extractedText: `PDF uploaded for conversation. You can now ask questions about: ${req.file.originalname}`,
                    integrationAnalysis: null,
                    fileName: req.file.originalname,
                    extractionDate: new Date().toISOString(),
                    fileId: fileId,
                    cacheId: cache.name,
                    processingMode: 'simple_ocr',
                    isFullText: true
                });
                
            } catch (uploadError) {
                console.error(`[${new Date().toISOString()}] Error uploading to Gemini:`, uploadError);
                
                // Clean up temp file if it exists
                if (fs.existsSync(tempFilePath)) {
                    fs.unlinkSync(tempFilePath);
                }
                
                // Return error without fallback
                res.status(500).json({ 
                    error: `Failed to upload PDF to Gemini cache service: ${uploadError.message}` 
                });
            }
        }
    } catch (error) {
        console.error(`[${new Date().toISOString()}] Error during data extraction:`, error);
        res.status(500).json({ error: `An error occurred during PDF processing: ${error.message}` });
    }
});

// Helper function to generate unique session ID
function generateSessionId() {
    return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// A new helper function to format the history for the prompt
function formatConversationHistory(history) {
    if (!history || history.length === 0) return "No previous conversation history.";
    // We take the last 10 messages to keep the prompt from getting too long
    return history.slice(-10).map(msg => `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.parts[0].text}`).join('\n');
}

// ===== CHAT HISTORY ENDPOINTS =====

// Debug endpoint to check database content
app.get('/api/debug/database', async (req, res) => {
    try {
        console.log('ğŸ” Debug endpoint called - checking database...');
        
        const users = await User.find({}).select('email name createdAt');
        console.log('ğŸ‘¥ Found users:', users.length);
        
        const chats = await ChatHistory.find({}).select('userId sessionId title totalMessages createdAt messages');
        console.log('ğŸ’¬ Found chats:', chats.length);
        
        // Log detailed chat info
        chats.forEach(chat => {
            console.log(`ğŸ“ Chat ${chat.sessionId}: ${chat.totalMessages} messages, title: ${chat.title}`);
        });
        
        res.json({
            totalUsers: users.length,
            users: users,
            totalChats: chats.length,
            chats: chats.map(chat => ({
                ...chat.toObject(),
                messageDetails: chat.messages.map(msg => ({
                    role: msg.role,
                    contentPreview: msg.content.substring(0, 50) + '...',
                    timestamp: msg.timestamp
                }))
            }))
        });
    } catch (error) {
        console.error('âŒ Database debug error:', error);
        res.status(500).json({ error: error.message });
    }
});

// Test endpoint to create a simple chat
app.post('/api/debug/test-save', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ error: 'Not authenticated' });
    }
    
    try {
        console.log('ğŸ§ª Test save endpoint called');
        
        const testSessionId = 'test_' + Date.now();
        console.log('ğŸ“ Creating test session:', testSessionId);
        
        const testChat = await ChatHistory.createNewSession(req.user._id, testSessionId, 'Test Chat');
        console.log('âœ… Test session created:', testChat._id);
        
        await testChat.addMessage('user', 'This is a test message', {});
        console.log('âœ… Test message added');
        
        await testChat.addMessage('assistant', 'This is a test response', {});
        console.log('âœ… Test response added');
        
        // Verify it was saved
        const saved = await ChatHistory.findById(testChat._id);
        console.log('ğŸ” Verification - saved chat has', saved.messages.length, 'messages');
        
        res.json({
            success: true,
            sessionId: testSessionId,
            messageCount: saved.messages.length,
            chat: saved
        });
        
    } catch (error) {
        console.error('âŒ Test save error:', error);
        res.status(500).json({ error: error.message });
    }
});

// Get all chat sessions for a user
app.get('/api/chat/sessions', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ error: 'Not authenticated' });
    }
    
    try {
        const sessions = await ChatHistory.findUserSessions(req.user._id);
        res.json(sessions);
    } catch (error) {
        console.error('Error fetching chat sessions:', error);
        res.status(500).json({ error: 'Failed to fetch chat sessions' });
    }
});

// Get messages for a specific session
app.get('/api/chat/session/:sessionId', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ error: 'Not authenticated' });
    }
    
    try {
        const { sessionId } = req.params;
        const chatHistory = await ChatHistory.findOne({
            userId: req.user._id,
            sessionId: sessionId
        });
        
        if (!chatHistory) {
            return res.status(404).json({ error: 'Chat session not found' });
        }
        
        res.json(chatHistory);
    } catch (error) {
        console.error('Error fetching chat session:', error);
        res.status(500).json({ error: 'Failed to fetch chat session' });
    }
});

// Create a new chat session
app.post('/api/chat/session/new', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ error: 'Not authenticated' });
    }
    
    try {
        const { title } = req.body;
        const sessionId = generateSessionId();
        
        const newSession = await ChatHistory.createNewSession(
            req.user._id,
            sessionId,
            title || 'New Conversation'
        );
        
        res.json({
            sessionId: newSession.sessionId,
            title: newSession.title,
            createdAt: newSession.createdAt
        });
    } catch (error) {
        console.error('Error creating new chat session:', error);
        res.status(500).json({ error: 'Failed to create new chat session' });
    }
});

// Save a message to a chat session
app.post('/api/chat/message', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ error: 'Not authenticated' });
    }
    
    try {
        const { sessionId, role, content, metadata = {} } = req.body;
        
        if (!sessionId || !role || !content) {
            return res.status(400).json({ error: 'sessionId, role, and content are required' });
        }
        
        let chatHistory = await ChatHistory.findOne({
            userId: req.user._id,
            sessionId: sessionId
        });
        
        if (!chatHistory) {
            // Create new session if it doesn't exist
            chatHistory = await ChatHistory.createNewSession(req.user._id, sessionId);
        }
        
        await chatHistory.addMessage(role, content, metadata);
        
        res.json({
            success: true,
            messageCount: chatHistory.messageCount,
            title: chatHistory.title
        });
    } catch (error) {
        console.error('Error saving message:', error);
        res.status(500).json({ error: 'Failed to save message' });
    }
});

// Delete a chat session (permanently)
app.delete('/api/chat/session/:sessionId', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ error: 'Not authenticated' });
    }
    
    try {
        const { sessionId } = req.params;
        
        console.log(`Deleting chat session: ${sessionId} for user: ${req.user.email}`);
        
        const result = await ChatHistory.findOneAndDelete({
            userId: req.user._id,
            sessionId: sessionId
        });
        
        if (!result) {
            console.log(`Chat session not found: ${sessionId}`);
            return res.status(404).json({ error: 'Chat session not found' });
        }
        
        console.log(`âœ… Chat session deleted successfully: ${sessionId}`);
        res.json({ success: true });
    } catch (error) {
        console.error('âŒ Error deleting chat session:', error);
        res.status(500).json({ error: 'Failed to delete chat session' });
    }
});

// Update chat session title
app.put('/api/chat/session/:sessionId/title', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ error: 'Not authenticated' });
    }
    
    try {
        const { sessionId } = req.params;
        const { title } = req.body;
        
        if (!title) {
            return res.status(400).json({ error: 'Title is required' });
        }
        
        const chatHistory = await ChatHistory.findOneAndUpdate(
            { userId: req.user._id, sessionId: sessionId },
            { title: title },
            { new: true }
        );
        
        if (!chatHistory) {
            return res.status(404).json({ error: 'Chat session not found' });
        }
        
        res.json({ success: true, title: chatHistory.title });
    } catch (error) {
        console.error('Error updating chat session title:', error);
        res.status(500).json({ error: 'Failed to update chat session title' });
    }
});

// ğŸ”„ Undo Action
app.post('/api/action/undo', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ error: 'Not authenticated' });
    }

    try {
        const { sessionId } = req.body;
        
        // ××¦× ××ª ×”×¤×¢×•×œ×” ×”××—×¨×•× ×” ×©×‘×•×¦×¢×”
        const lastAction = await ActionHistory.findLastExecuted(sessionId);
        
        if (!lastAction) {
            return res.status(404).json({ 
                error: '××™×Ÿ ×¤×¢×•×œ×•×ª ×œ×‘×™×˜×•×œ',
                canUndo: false 
            });
        }

        console.log(`â†©ï¸ Undoing action for session ${sessionId}`);

        // ×©×—×–×¨ ××ª ×”××¦×‘ ×”××§×•×¨×™
        const oauth2Client = new google.auth.OAuth2();
        oauth2Client.setCredentials({ access_token: req.user.accessToken });
        const sheets = google.sheets({ version: 'v4', auth: oauth2Client });

        const revertRequests = [];
        let message = '';
        
        // Build revert requests based on action type
        switch (lastAction.actionType || 'AI_ACTION') {
            case 'AI_ACTION':
                // Standard AI action undo - restore original values and formatting
                lastAction.changedCells.forEach(cellAddress => {
                    const original = lastAction.snapshotBefore[cellAddress];
                    
                    // ×©×—×–×¨ ×¢×¨×š ××§×•×¨×™
                    let valuePayload;
                    if (original.value === "") {
                        valuePayload = null;
                    } else if (typeof original.value === 'number') {
                        valuePayload = { numberValue: original.value };
                    } else if (typeof original.value === 'string' && original.value.startsWith('=')) {
                        valuePayload = { formulaValue: original.value };
                    } else {
                        valuePayload = { stringValue: original.value };
                    }
                    
                    revertRequests.push({
                        updateCells: {
                            range: cellToRange(cellAddress, lastAction.sheetId),
                            rows: [{ values: [{ userEnteredValue: valuePayload }] }],
                            fields: "userEnteredValue"
                        }
                    });
                    
                    // ×©×—×–×¨ ×¢×™×¦×•×‘ ××§×•×¨×™
                    revertRequests.push({
                        repeatCell: {
                            range: cellToRange(cellAddress, lastAction.sheetId),
                            cell: { userEnteredFormat: { backgroundColor: original.backgroundColor } },
                            fields: "userEnteredFormat.backgroundColor"
                        }
                    });
                });
                message = `×”×¤×¢×•×œ×” ×‘×•×˜×œ×” ×‘×”×¦×œ×—×” - ${lastAction.changedCells.length} ×ª××™× ×”×•×—×–×¨×• ×œ××¦×‘× ×”××§×•×¨×™`;
                break;

            case 'APPROVE_ALL':
                // Undo approval - restore green highlighting and reactivate original AI action
                lastAction.changedCells.forEach(cellAddress => {
                    const original = lastAction.snapshotBefore[cellAddress];
                    
                    // ×”×—×–×¨ ×”×“×’×©×” ×™×¨×•×§×” (××”-snapshot ×œ×¤× ×™ ×”××™×©×•×¨)
                    revertRequests.push({
                        repeatCell: {
                            range: cellToRange(cellAddress, lastAction.sheetId),
                            cell: { userEnteredFormat: { backgroundColor: original.backgroundColor || { red: 0.85, green: 0.95, blue: 0.85 } } },
                            fields: "userEnteredFormat.backgroundColor"
                        }
                    });
                });

                // ×—×©×•×‘: ×”×—×–×¨ ××ª ×¤×¢×•×œ×ª ×”-AI ×”××§×•×¨×™×ª ×œ×¡×˜×˜×•×¡ EXECUTED ×›×“×™ ×©× ×™×ª×Ÿ ×™×”×™×” ×œ×¢×©×•×ª ×¢×œ×™×” Undo
                const originalAIAction = await ActionHistory.findOne({
                    sessionId: sessionId,
                    actionType: 'AI_ACTION',
                    status: 'EXECUTED',
                    changedCells: { $in: lastAction.changedCells }
                }).sort({ createdAt: -1 });
                
                if (originalAIAction) {
                    console.log(`ğŸ”„ Restoring AI action ${originalAIAction._id} to EXECUTED status`);
                    // ×¤×¢×•×œ×ª ×”-AI ×”××§×•×¨×™×ª ×—×•×–×¨×ª ×œ×”×™×•×ª × ×™×ª× ×ª ×œ-Undo
                }

                message = `×”××™×©×•×¨ ×‘×•×˜×œ - ${lastAction.changedCells.length} ×ª××™× ×”×•×—×–×¨×• ×œ×”×“×’×©×” ×™×¨×•×§×”`;
                break;

            case 'REJECT_ALL':
                // Undo rejection - restore the values and green state from before rejection
                lastAction.changedCells.forEach(cellAddress => {
                    const original = lastAction.snapshotBefore[cellAddress];
                    
                    // ×©×—×–×¨ ×¢×¨×š ×©×”×™×” ×œ×¤× ×™ ×”×“×—×™×™×”
                    let valuePayload;
                    if (original.value === "") {
                        valuePayload = null;
                    } else if (typeof original.value === 'number') {
                        valuePayload = { numberValue: original.value };
                    } else if (typeof original.value === 'string' && original.value.startsWith('=')) {
                        valuePayload = { formulaValue: original.value };
                    } else {
                        valuePayload = { stringValue: original.value };
                    }
                    
                    revertRequests.push({
                        updateCells: {
                            range: cellToRange(cellAddress, lastAction.sheetId),
                            rows: [{ values: [{ userEnteredValue: valuePayload }] }],
                            fields: "userEnteredValue"
                        }
                    });
                    
                    // ×©×—×–×¨ ×¢×™×¦×•×‘ ×©×”×™×” ×œ×¤× ×™ ×”×“×—×™×™×” (×‘×“×¨×š ×›×œ×œ ×™×¨×•×§)
                    revertRequests.push({
                        repeatCell: {
                            range: cellToRange(cellAddress, lastAction.sheetId),
                            cell: { userEnteredFormat: { backgroundColor: original.backgroundColor || { red: 0.85, green: 0.95, blue: 0.85 } } },
                            fields: "userEnteredFormat.backgroundColor"
                        }
                    });
                });

                // ×—×©×•×‘: ×”×—×–×¨ ××ª ×¤×¢×•×œ×ª ×”-AI ×”××§×•×¨×™×ª ×œ×¡×˜×˜×•×¡ EXECUTED ×›×“×™ ×©× ×™×ª×Ÿ ×™×”×™×” ×œ×¢×©×•×ª ×¢×œ×™×” Undo
                const originalAIActionReject = await ActionHistory.findOne({
                    sessionId: sessionId,
                    actionType: 'AI_ACTION',
                    status: 'EXECUTED',
                    changedCells: { $in: lastAction.changedCells }
                }).sort({ createdAt: -1 });
                
                if (originalAIActionReject) {
                    console.log(`ğŸ”„ Restoring AI action ${originalAIActionReject._id} to EXECUTED status after reject undo`);
                    // ×¤×¢×•×œ×ª ×”-AI ×”××§×•×¨×™×ª ×—×•×–×¨×ª ×œ×”×™×•×ª × ×™×ª× ×ª ×œ-Undo
                }

                message = `×”×“×—×™×™×” ×‘×•×˜×œ×” - ${lastAction.changedCells.length} ×ª××™× ×”×•×—×–×¨×• ×œ××¦×‘× ×œ×¤× ×™ ×”×“×—×™×™×”`;
                break;

            default:
                lastAction.changedCells.forEach(cellAddress => {
                    const original = lastAction.snapshotBefore[cellAddress];
                    
                    let valuePayload;
                    if (original.value === "") {
                        valuePayload = null;
                    } else if (typeof original.value === 'number') {
                        valuePayload = { numberValue: original.value };
                    } else if (typeof original.value === 'string' && original.value.startsWith('=')) {
                        valuePayload = { formulaValue: original.value };
                    } else {
                        valuePayload = { stringValue: original.value };
                    }
                    
                    revertRequests.push({
                        updateCells: {
                            range: cellToRange(cellAddress, lastAction.sheetId),
                            rows: [{ values: [{ userEnteredValue: valuePayload }] }],
                            fields: "userEnteredValue"
                        }
                    });
                    
                    revertRequests.push({
                        repeatCell: {
                            range: cellToRange(cellAddress, lastAction.sheetId),
                            cell: { userEnteredFormat: { backgroundColor: original.backgroundColor } },
                            fields: "userEnteredFormat.backgroundColor"
                        }
                    });
                });
                message = `×”×¤×¢×•×œ×” ×‘×•×˜×œ×” ×‘×”×¦×œ×—×” - ${lastAction.changedCells.length} ×ª××™× ×”×•×—×–×¨×•`;
        }

        await sheets.spreadsheets.batchUpdate({
            spreadsheetId: lastAction.spreadsheetId,
            resource: { requests: revertRequests }
        });

        // ×¢×“×›×Ÿ ×¡×˜×˜×•×¡ ×œUNDONE
        lastAction.status = 'UNDONE';
        await lastAction.save();

        console.log(`â†©ï¸ Action undone successfully for session ${sessionId}`);

        const status = await ActionHistory.getStatus(sessionId);
        res.json({ 
            success: true, 
            message: message,
            actionType: lastAction.actionType,
            ...status
        });

    } catch (error) {
        console.error('Error in undo action:', error);
        res.status(500).json({ error: '×©×’×™××” ×‘×‘×™×˜×•×œ ×”×¤×¢×•×œ×”' });
    }
});

// â¤´ï¸ Redo Action  
app.post('/api/action/redo', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ error: 'Not authenticated' });
    }

    try {
        const { sessionId } = req.body;
        
        // ××¦× ××ª ×”×¤×¢×•×œ×” ×”××—×¨×•× ×” ×©×‘×•×˜×œ×”
        const lastUndone = await ActionHistory.findLastUndone(sessionId);
        
        if (!lastUndone) {
            return res.status(404).json({ 
                error: '××™×Ÿ ×¤×¢×•×œ×•×ª ×œ×©×—×–×•×¨',
                canRedo: false 
            });
        }

        console.log(`â¤´ï¸ Redoing action for session ${sessionId}`);

        // ×‘×¦×¢ ×©×•×‘ ××ª ×”×©×™× ×•×™ ×”××§×•×¨×™
        const oauth2Client = new google.auth.OAuth2();
        oauth2Client.setCredentials({ access_token: req.user.accessToken });
        const sheets = google.sheets({ version: 'v4', auth: oauth2Client });

        const redoRequests = [];
        
        lastUndone.changeRequest.forEach(action => {
            const range = cellToRange(action.cell, lastUndone.sheetId);

            switch (action.type) {
                case 'UPDATE':
                    // Determine the correct value type for redo
                    let userEnteredValue;
                    if (typeof action.value === 'number') {
                        userEnteredValue = { numberValue: action.value };
                    } else if (typeof action.value === 'string' && action.value.startsWith('=')) {
                        userEnteredValue = { formulaValue: action.value };
                    } else {
                        userEnteredValue = { stringValue: action.value };
                    }
                    
                    redoRequests.push({
                        updateCells: {
                            rows: [{ values: [{ userEnteredValue: userEnteredValue }] }],
                            range: range,
                            fields: "userEnteredValue"
                        }
                    });
                    break;

                case 'CLEAR':
                    redoRequests.push({
                        updateCells: {
                            range: range,
                            fields: "*"
                        }
                    });
                    break;
            }
        });

        await sheets.spreadsheets.batchUpdate({
            spreadsheetId: lastUndone.spreadsheetId,
            resource: { requests: redoRequests }
        });

        // ×¢×“×›×Ÿ ×¡×˜×˜×•×¡ ×‘×—×–×¨×” ×œEXECUTED
        lastUndone.status = 'EXECUTED';
        await lastUndone.save();

        console.log(`â¤´ï¸ Action redone successfully for session ${sessionId}`);

        const status = await ActionHistory.getStatus(sessionId);
        res.json({ 
            success: true, 
            message: `×”×¤×¢×•×œ×” ×©×•×—×–×¨×” ×‘×”×¦×œ×—×” - ${lastUndone.changedCells.length} ×ª××™× ×©×•× ×•`,
            ...status
        });

    } catch (error) {
        console.error('Error in redo action:', error);
        res.status(500).json({ error: '×©×’×™××” ×‘×©×—×–×•×¨ ×”×¤×¢×•×œ×”' });
    }
});

// ğŸ“Š Get Undo/Redo Status
app.get('/api/action/status/:sessionId', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ error: 'Not authenticated' });
    }

    try {
        const { sessionId } = req.params;
        const status = await ActionHistory.getStatus(sessionId);
        
        // ×—×™×©×•×‘ changesCount ××“×•×™×§ ×™×•×ª×¨ - ×¨×§ ×¢×‘×•×¨ AI_ACTION ×©×™×© ×‘×• ×ª××™× ×™×¨×•×§×™×
        let changesCount = 0;
        if (status.canUndo) {
            // ××¦× ××ª ×”×¤×¢×•×œ×” ×”××—×¨×•× ×” ××¡×•×’ AI_ACTION (×©×™×© ×‘×” ×ª××™× ×™×¨×•×§×™×)
            const lastAIAction = await ActionHistory.findOne({
                sessionId,
                actionType: 'AI_ACTION',
                status: 'EXECUTED'
            }).sort({ createdAt: -1 });
            
            console.log('ğŸ” Last AI action found:', lastAIAction ? 'YES' : 'NO');
            if (lastAIAction) {
                console.log('ğŸ” AI action type:', lastAIAction.actionType);
                console.log('ğŸ“Š Changed cells in AI action:', lastAIAction.changedCells);
                changesCount = lastAIAction.changedCells ? lastAIAction.changedCells.length : 0;
            } else {
                // ××™×Ÿ AI_ACTION - ××•×œ×™ ×™×© ×¨×§ APPROVE_ALL ××• REJECT_ALL
                const recentAction = await ActionHistory.findOne({
                    sessionId,
                    status: 'EXECUTED'
                }).sort({ createdAt: -1 });
                
                console.log('ğŸ” Other recent action:', recentAction ? recentAction.actionType : 'NONE');
                changesCount = 0; // ××™×Ÿ ×ª××™× ×™×¨×•×§×™× ×× ××™×Ÿ AI_ACTION
            }
        }
        
        console.log('ğŸ“ˆ Final changesCount:', changesCount, 'canUndo:', status.canUndo);
        
        res.json({
            ...status,
            changesCount
        });
    } catch (error) {
        console.error('Error getting action status:', error);
        res.status(500).json({ error: 'Failed to get action status' });
    }
});

// ğŸŸ¢ Helper function to find green cells
async function findGreenCells(spreadsheetId, selectedSheetName, sheetId, sheets) {
    try {
        // Get detailed sheet data with formatting
        const response = await sheets.spreadsheets.get({
            spreadsheetId: spreadsheetId,
            ranges: [`${selectedSheetName}`],
            includeGridData: true
        });

        const greenCells = [];
        const GREEN_COLOR = { red: 0.85, green: 0.95, blue: 0.85 };
        
        if (response.data.sheets && response.data.sheets[0] && response.data.sheets[0].data) {
            const sheetData = response.data.sheets[0].data[0];
            if (sheetData.rowData) {
                sheetData.rowData.forEach((row, rowIndex) => {
                    if (row.values) {
                        row.values.forEach((cell, colIndex) => {
                            if (cell.effectiveFormat && cell.effectiveFormat.backgroundColor) {
                                const bg = cell.effectiveFormat.backgroundColor;
                                // Check if cell has green background (AI highlight)
                                if (bg.red === GREEN_COLOR.red && bg.green === GREEN_COLOR.green && bg.blue === GREEN_COLOR.blue) {
                                    const cellAddress = String.fromCharCode(65 + colIndex) + (rowIndex + 1);
                                    greenCells.push(cellAddress);
                                }
                            }
                        });
                    }
                });
            }
        }
        
        return greenCells;
    } catch (error) {
        console.error('Error finding green cells:', error);
        return [];
    }
}

// âœ… Approve All Changes
app.post('/api/action/approve-all', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ error: 'Not authenticated' });
    }

    try {
        const { spreadsheetId, selectedSheetName, sheetId, sessionId } = req.body;
        
        if (!spreadsheetId || !selectedSheetName || !sessionId) {
            return res.status(400).json({ error: 'Missing required parameters' });
        }

        const oauth2Client = new google.auth.OAuth2();
        oauth2Client.setCredentials({ access_token: req.user.accessToken });
        const sheets = google.sheets({ version: 'v4', auth: oauth2Client });
        
        // Find all green cells
        const greenCells = await findGreenCells(spreadsheetId, selectedSheetName, sheetId, sheets);
        
        if (greenCells.length === 0) {
            return res.json({ message: '×œ× × ××¦××• ×©×™× ×•×™×™× ×œ××™×©×•×¨', greenCells: [] });
        }

        // Take snapshot before change (with green colors)
        const snapshotBefore = await takeSnapshot(greenCells, sheets, spreadsheetId, selectedSheetName, sheetId);

        // Remove green background from all cells (approve changes)
        const approveRequests = greenCells.map(cellAddress => {
            const range = cellToRange(cellAddress, sheetId);
            return {
                repeatCell: {
                    range: range,
                    cell: {
                        userEnteredFormat: {
                            backgroundColor: null // Remove green, revert to original
                        }
                    },
                    fields: "userEnteredFormat.backgroundColor"
                }
            };
        });

        // Execute the approval
        await sheets.spreadsheets.batchUpdate({
            spreadsheetId: spreadsheetId,
            resource: { requests: approveRequests }
        });

        // Save action to history
        const actionHistory = new ActionHistory({
            userId: req.user._id,
            sessionId: sessionId,
            actionType: 'APPROVE_ALL',
            snapshotBefore: snapshotBefore,
            changeRequest: approveRequests,
            status: 'EXECUTED',
            spreadsheetId: spreadsheetId,
            sheetId: sheetId,
            selectedSheetName: selectedSheetName,
            changedCells: greenCells
        });

        await actionHistory.save();

        console.log(`âœ… Approved ${greenCells.length} changes for session ${sessionId}`);
        res.json({ 
            message: `âœ… ××•×©×¨×• ${greenCells.length} ×©×™× ×•×™×™×`, 
            greenCells: greenCells,
            actionId: actionHistory._id
        });

    } catch (error) {
        console.error('Error in approve all:', error);
        res.status(500).json({ error: '×©×’×™××” ×‘××™×©×•×¨ ×”×©×™× ×•×™×™×' });
    }
});

// âŒ Reject All Changes  
app.post('/api/action/reject-all', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ error: 'Not authenticated' });
    }

    try {
        const { spreadsheetId, selectedSheetName, sheetId, sessionId } = req.body;
        
        if (!spreadsheetId || !selectedSheetName || !sessionId) {
            return res.status(400).json({ error: 'Missing required parameters' });
        }

        const oauth2Client = new google.auth.OAuth2();
        oauth2Client.setCredentials({ access_token: req.user.accessToken });
        const sheets = google.sheets({ version: 'v4', auth: oauth2Client });
        
        // Find all green cells
        const greenCells = await findGreenCells(spreadsheetId, selectedSheetName, sheetId, sheets);
        
        if (greenCells.length === 0) {
            return res.json({ message: '×œ× × ××¦××• ×©×™× ×•×™×™× ×œ×“×—×™×™×”', greenCells: [] });
        }

        // Take snapshot before rejection (current state with green)
        const snapshotBefore = await takeSnapshot(greenCells, sheets, spreadsheetId, selectedSheetName, sheetId);

        // Find the original state before AI changes
        // We need to look through the history to find the original values
        const aiActions = await ActionHistory.find({
            sessionId: sessionId,
            actionType: 'AI_ACTION',
            status: 'EXECUTED'
        }).sort({ createdAt: 1 }); // Oldest first

        // Build reject requests by restoring original values and colors
        const rejectRequests = [];
        
        for (const cellAddress of greenCells) {
            const range = cellToRange(cellAddress, sheetId);
            
            // Find original value from first AI action that affected this cell
            let originalValue = '';
            let originalFormatting = null;
            
            for (const action of aiActions) {
                if (action.changedCells.includes(cellAddress) && action.snapshotBefore[cellAddress]) {
                    originalValue = action.snapshotBefore[cellAddress].value || '';
                    originalFormatting = action.snapshotBefore[cellAddress].formatting || null;
                    break;
                }
            }

            // Restore original value
            if (originalValue !== undefined) {
                rejectRequests.push({
                    updateCells: {
                        range: range,
                        rows: [{
                            values: [{
                                userEnteredValue: originalValue === '' ? {} : { stringValue: originalValue.toString() }
                            }]
                        }],
                        fields: "userEnteredValue"
                    }
                });
            }

            // Restore original formatting
            rejectRequests.push({
                repeatCell: {
                    range: range,
                    cell: {
                        userEnteredFormat: originalFormatting || { backgroundColor: null }
                    },
                    fields: "*"
                }
            });
        }

        // Execute the rejection
        if (rejectRequests.length > 0) {
            await sheets.spreadsheets.batchUpdate({
                spreadsheetId: spreadsheetId,
                resource: { requests: rejectRequests }
            });
        }

        // Save action to history
        const actionHistory = new ActionHistory({
            userId: req.user._id,
            sessionId: sessionId,
            actionType: 'REJECT_ALL',
            snapshotBefore: snapshotBefore,
            changeRequest: rejectRequests,
            status: 'EXECUTED',
            spreadsheetId: spreadsheetId,
            sheetId: sheetId,
            selectedSheetName: selectedSheetName,
            changedCells: greenCells
        });

        await actionHistory.save();

        console.log(`âŒ Rejected ${greenCells.length} changes for session ${sessionId}`);
        res.json({ 
            message: `âŒ × ×“×—×• ${greenCells.length} ×©×™× ×•×™×™×`, 
            greenCells: greenCells,
            actionId: actionHistory._id
        });

    } catch (error) {
        console.error('Error in reject all:', error);
        res.status(500).json({ error: '×©×’×™××” ×‘×“×—×™×™×ª ×”×©×™× ×•×™×™×' });
    }
});

/**
 * Act III: The Streaming Conversation (with Agent Mode)
 * This endpoint now has two distinct code paths based on the `isAgentMode` flag
 * to ensure a secure separation between read-only chat and read-write agent actions.
 */
app.post('/api/chat-stream', async (req, res) => {
    // 1. DESTRUCTURE REQUEST: Now includes spreadsheetId and accessToken from the frontend.
    const { question, sheetData, extractedPdfData, extractedExcelData, isAgentMode, conversationHistory, spreadsheetId, accessToken, sheetsMetadata, selectedSheetName, sessionId, sheetInstructions } = req.body;

    if (!question) {
        return res.status(400).json({ error: 'Question is required.' });
    }

    console.log('ğŸ”¥ Chat request received. Sheet instructions:', !!sheetInstructions);
    if (sheetInstructions) {
        console.log('ğŸ“‹ Sheet instructions preview:', sheetInstructions.substring(0, 150) + '...');
    }

    // ğŸ”„ ×‘×“×™×§×” ×œ×¤×§×•×“×•×ª Undo/Redo
    const questionLower = question.toLowerCase().trim();
    const undoKeywords = ['×‘×˜×œ', 'undo', '×‘×˜×œ ×¤×¢×•×œ×”', '×‘×˜×œ ××ª ×”×¤×¢×•×œ×”', '×—×–×•×¨ ××—×•×¨×”'];
    const redoKeywords = ['×©×—×–×¨', 'redo', '×©×—×–×¨ ×¤×¢×•×œ×”', '×¢×©×” ×©×•×‘', '×—×–×•×¨ ×§×“×™××”'];
    
    if (undoKeywords.some(keyword => questionLower.includes(keyword))) {
        // ×‘×“×•×§ ×× ×™×© ×¤×¢×•×œ×” ×œ×‘×™×˜×•×œ
        const lastAction = await ActionHistory.findLastExecuted(currentSessionId);
        if (!lastAction) {
            res.setHeader('Content-Type', 'text/plain; charset=utf-8');
            res.write('âŒ ××™×Ÿ ×¤×¢×•×œ×•×ª ×œ×‘×™×˜×•×œ');
            res.end();
            return;
        }
        
        // ×‘×¦×¢ Undo
        try {
            const oauth2Client = new google.auth.OAuth2();
            oauth2Client.setCredentials({ access_token: accessToken });
            const sheets = google.sheets({ version: 'v4', auth: oauth2Client });

            const revertRequests = [];
            lastAction.changedCells.forEach(cellAddress => {
                const original = lastAction.snapshotBefore[cellAddress];
                let valuePayload;
                if (original.value === "") {
                    valuePayload = null;
                } else if (typeof original.value === 'number') {
                    valuePayload = { numberValue: original.value };
                } else if (typeof original.value === 'string' && original.value.startsWith('=')) {
                    valuePayload = { formulaValue: original.value };
                } else {
                    valuePayload = { stringValue: original.value };
                }
                
                revertRequests.push({
                    updateCells: {
                        range: cellToRange(cellAddress, lastAction.sheetId),
                        rows: [{ values: [{ userEnteredValue: valuePayload }] }],
                        fields: "userEnteredValue"
                    }
                });
                
                revertRequests.push({
                    repeatCell: {
                        range: cellToRange(cellAddress, lastAction.sheetId),
                        cell: { userEnteredFormat: { backgroundColor: original.backgroundColor } },
                        fields: "userEnteredFormat.backgroundColor"
                    }
                });
            });

            await sheets.spreadsheets.batchUpdate({
                spreadsheetId: lastAction.spreadsheetId,
                resource: { requests: revertRequests }
            });

            lastAction.status = 'UNDONE';
            await lastAction.save();

            console.log(`â†©ï¸ Chat Undo executed for session ${currentSessionId}`);
            
            res.setHeader('Content-Type', 'text/plain; charset=utf-8');
            res.write(`â†©ï¸ ×”×¤×¢×•×œ×” ×‘×•×˜×œ×” ×‘×”×¦×œ×—×”! ×—×–×¨×ª×™ ${lastAction.changedCells.length} ×ª××™× ×œ××¦×‘ ×”×§×•×“×.`);
            res.end();
            return;
        } catch (error) {
            console.error('Error in chat undo:', error);
            res.setHeader('Content-Type', 'text/plain; charset=utf-8');
            res.write('âŒ ×©×’×™××” ×‘×‘×™×˜×•×œ ×”×¤×¢×•×œ×”');
            res.end();
            return;
        }
    }
    
    if (redoKeywords.some(keyword => questionLower.includes(keyword))) {
        // ×‘×“×•×§ ×× ×™×© ×¤×¢×•×œ×” ×œ×©×—×–×•×¨
        const lastUndone = await ActionHistory.findLastUndone(currentSessionId);
        if (!lastUndone) {
            res.setHeader('Content-Type', 'text/plain; charset=utf-8');
            res.write('âŒ ××™×Ÿ ×¤×¢×•×œ×•×ª ×œ×©×—×–×•×¨');
            res.end();
            return;
        }
        
        // ×‘×¦×¢ Redo
        try {
            const oauth2Client = new google.auth.OAuth2();
            oauth2Client.setCredentials({ access_token: accessToken });
            const sheets = google.sheets({ version: 'v4', auth: oauth2Client });

            const redoRequests = [];
            lastUndone.changeRequest.forEach(action => {
                const range = cellToRange(action.cell, lastUndone.sheetId);

                switch (action.type) {
                    case 'UPDATE':
                        // Determine the correct value type for redo
                        let userEnteredValue;
                        if (typeof action.value === 'number') {
                            userEnteredValue = { numberValue: action.value };
                        } else if (typeof action.value === 'string' && action.value.startsWith('=')) {
                            userEnteredValue = { formulaValue: action.value };
                        } else {
                            userEnteredValue = { stringValue: action.value };
                        }
                        
                        redoRequests.push({
                            updateCells: {
                                rows: [{ values: [{ userEnteredValue: userEnteredValue }] }],
                                range: range,
                                fields: "userEnteredValue"
                            }
                        });
                        break;

                    case 'CLEAR':
                        redoRequests.push({
                            updateCells: {
                                range: range,
                                fields: "*"
                            }
                        });
                        break;
                }
            });

            await sheets.spreadsheets.batchUpdate({
                spreadsheetId: lastUndone.spreadsheetId,
                resource: { requests: redoRequests }
            });

            lastUndone.status = 'EXECUTED';
            await lastUndone.save();

            console.log(`â¤´ï¸ Chat Redo executed for session ${currentSessionId}`);
            
            res.setHeader('Content-Type', 'text/plain; charset=utf-8');
            res.write(`â¤´ï¸ ×”×¤×¢×•×œ×” ×©×•×—×–×¨×” ×‘×”×¦×œ×—×”! ×—×–×¨×ª×™ ${lastUndone.changedCells.length} ×ª××™× ×œ×©×™× ×•×™ ×”×—×“×©.`);
            res.end();
            return;
        } catch (error) {
            console.error('Error in chat redo:', error);
            res.setHeader('Content-Type', 'text/plain; charset=utf-8');
            res.write('âŒ ×©×’×™××” ×‘×©×—×–×•×¨ ×”×¤×¢×•×œ×”');
            res.end();
            return;
        }
    }

    // ğŸ›¡ï¸ ×‘×“×™×§×” ×—×“×©×” ×œAgent Mode
    if (isAgentMode && sheetData && (!selectedSheetName || !sheetsMetadata)) {
        return res.status(400).send('×œ× × ×™×ª×Ÿ ×œ×¢×¨×•×š ×’×œ×™×•×Ÿ ×œ×œ× ×‘×—×™×¨×ª ×’×œ×™×•×Ÿ ×¡×¤×¦×™×¤×™. ×× × ×‘×—×¨ ×’×œ×™×•×Ÿ ×ª×—×™×œ×”.');
    }

    // Generate session ID if not provided
    const currentSessionId = sessionId || generateSessionId();
    let chatHistory = null;

    // Save to database if user is authenticated
    if (req.isAuthenticated()) {
        try {
            console.log(`ğŸ” Looking for existing session: ${currentSessionId} for user ID: ${req.user._id}`);
            
            chatHistory = await ChatHistory.findOne({
                userId: req.user._id,
                sessionId: currentSessionId
            });
            
            console.log(`ğŸ” Found existing session:`, chatHistory ? 'YES' : 'NO');
            
            if (!chatHistory) {
                console.log(`ğŸ“ Creating new chat session: ${currentSessionId} for user: ${req.user.email}`);
                try {
                    chatHistory = await ChatHistory.createNewSession(req.user._id, currentSessionId);
                    console.log(`âœ… Chat session created with ID: ${chatHistory._id}`);
                    console.log(`ğŸ“Š Session details:`, {
                        sessionId: chatHistory.sessionId,
                        userId: chatHistory.userId,
                        title: chatHistory.title,
                        messageCount: chatHistory.messages.length
                    });
                } catch (createError) {
                    console.error(`âŒ Failed to create chat session: ${createError.message}`);
                    console.error('Create error details:', createError);
                    throw createError;
                }
            }

            // Save user message
            console.log(`ğŸ’¾ Attempting to save user message to session: ${currentSessionId}`);
            console.log(`ğŸ“ Message content: "${question.substring(0, 50)}..."`);
            
            try {
                const beforeSave = {
                    sessionId: chatHistory.sessionId,
                    messageCount: chatHistory.messages.length,
                    lastActivity: chatHistory.lastActivity
                };
                console.log(`ğŸ“Š Before save:`, beforeSave);
                
                const result = await chatHistory.addMessage('user', question, {
                    isAgentMode: !!isAgentMode,
                    spreadsheetId: spreadsheetId || null,
                    selectedSheetName: selectedSheetName || null,
                    hasAttachments: !!(extractedPdfData || extractedExcelData),
                    attachmentTypes: [
                        ...(extractedPdfData ? ['pdf'] : []),
                        ...(extractedExcelData ? ['excel'] : [])
                    ]
                });
                
                console.log(`ğŸ“Š After save:`, {
                    messageCount: chatHistory.messages.length,
                    lastActivity: chatHistory.lastActivity,
                    saved: !!result
                });
                
                console.log(`âœ… User message saved successfully to MongoDB`);
                
                // Verify the save by checking database
                const verification = await ChatHistory.findOne({
                    userId: req.user._id,
                    sessionId: currentSessionId
                });
                console.log(`ğŸ” Verification - Messages in DB: ${verification ? verification.messages.length : 'NOT FOUND'}`);
                
            } catch (saveError) {
                console.error(`âŒ Failed to save user message: ${saveError.message}`);
                console.error('Save error details:', saveError);
                throw saveError;
            }
        } catch (error) {
            console.error('âŒ Error in chat history operation:', error);
            // Continue processing even if saving fails
        }
    } else {
        console.log('âŒ User not authenticated, skipping message save');
    }

    if (isAgentMode && sheetData) {
    /*********************************/
        /* AGENT MODE LOGIC         */
        /*********************************/
        console.log(`[${new Date().toISOString()}] Entering Agent Mode.`);

        // --- NEW: Build dynamic context based on available data ---
        let contextParts = [];
        if (sheetData) {
            console.log('ğŸ”¥ Agent Mode - Sheet data structure (first 3 rows):', JSON.stringify(sheetData.slice(0, 3), null, 2));
            contextParts.push(`
## The Analyst's Model (From Google Sheets)
This is the destination sheet you will be editing. It contains the user's financial model.
Note: Cells with 'formula' type contain both the calculated value and the original formula for better context.
\`\`\`json
${JSON.stringify(sheetData, null, 2)}
\`\`\`
`);
        }
        if (extractedPdfData) {
            // Check if we have a cached PDF (simple OCR mode) 
            if (extractedPdfData.cacheId && extractedPdfData.processingMode === 'simple_ocr') {
                console.log(`[${new Date().toISOString()}] Using cached PDF for Agent mode: ${extractedPdfData.cacheId}`);
                
                // For cached PDFs in Agent mode, we need to generate content with cache
                // But first, let's add the sheet context to help with structured understanding
                contextParts.push(`
## Current Google Sheet Structure
You are working with this financial model sheet:

\`\`\`json
${JSON.stringify(sheetData, null, 2)}
\`\`\`

## Sheet Analysis Context
${sheetInstructions || 'No specific instructions available'}

## Your Task
The user has uploaded a PDF document (available in the conversation context) and wants to update the Google Sheet above. 
Analyze the PDF content and suggest specific changes to the sheet structure, focusing on:
1. Which cells need to be updated with values from the PDF
2. Whether new rows/columns are needed
3. How to maintain the existing formulas and structure

You must provide specific cell references (like A1, B2, etc.) for any changes.
`);
            } else {
                // Traditional structured extraction mode
                const pdfText = extractedPdfData.extractedText || extractedPdfData;
                const integrationAnalysis = extractedPdfData.integrationAnalysis;
                
                contextParts.push(`
## The Company Report (From PDF)
This is the source document. You should extract values FROM this report TO FILL or UPDATE the Analyst's Model in the Google Sheet.

${pdfText}
`);

                // Add integration analysis if available
                if (integrationAnalysis) {
                    contextParts.push(`
## Internal Integration Analysis (CRITICAL CONTEXT)
This detailed analysis explains how the PDF data should integrate with the existing sheet. Use this as your guide for making changes:

${integrationAnalysis}
`);
                }
            }
        }
        // You can add a similar block for extractedExcelData if needed

        const fullContext = contextParts.join('\n\n');
        // --- END NEW ---

        // 2. NEW SMART AGENT LOGIC: First check if user is responding to pending clarification questions
        
        // Check if this message contains answers to a pending change plan
        const ChangePlan = require('./models/ChangePlan');
        const pendingPlans = await ChangePlan.find({ 
            userId: req.user._id, 
            sessionId: currentSessionId, 
            status: 'PENDING_CLARIFICATION' 
        }).sort({ createdAt: -1 }).limit(1);
        
        if (pendingPlans.length > 0) {
            const pendingPlan = pendingPlans[0];
            console.log(`ğŸ”„ Found pending change plan: ${pendingPlan.planId}`);
            
            // Check if the user message looks like it contains answers
            const userMessage = question.toLowerCase();
            const hasAnswerIndicators = userMessage.includes('×›×Ÿ') || userMessage.includes('×œ×') || 
                                      userMessage.includes('yes') || userMessage.includes('no') ||
                                      userMessage.includes('×¤×¨×•×™×§×˜×™×') || userMessage.includes('×”× ×”×œ×”') ||
                                      userMessage.split(/[,.\n]/).length >= 3; // Multiple parts suggesting multiple answers
            
            if (hasAnswerIndicators) {
                // This looks like the user is providing answers - inform them to use the proper interface
                const reminderMessage = `
ğŸ”„ **× ×¨××” ×©××ª×” ×× ×¡×” ×œ×¢× ×•×ª ×¢×œ ×©××œ×•×ª ×”×”×‘×”×¨×”**

×™×© ×œ×š ×ª×•×›× ×™×ª ×××ª×™× ×” (${pendingPlan.planId}) ×¢× 5 ×©××œ×•×ª ×”×‘×”×¨×”.
×× × ×”×©×ª××© ×‘×××©×§ ×”××™×•×—×“ ×©××•×¤×™×¢ ××¢×œ ×ª×™×‘×ª ×”×¦'××˜ ×›×“×™ ×œ×¢× ×•×ª ×¢×œ ×”×©××œ×•×ª.

×× ××™× ×š ×¨×•××” ××ª ×”×××©×§, × ×¡×” ×œ×¨×¢× ×Ÿ ××ª ×”×“×£.
`;
                res.setHeader('Content-Type', 'text/plain; charset=utf-8');
                res.write(reminderMessage);
                res.end();
                return;
            }
        }
        
        // Step 1: Significance Analysis (only if no pending plan)
        const significancePrompt = `
You are an expert financial analyst reviewing a user request for changes to a Google Sheets financial model.

**Your Task:** Determine if this request requires significant changes that need careful planning.

**Context:**
${fullContext}

${sheetInstructions ? `**Sheet Guidelines:**
${sheetInstructions}
---
` : ''}

**User Request:** "${question}"

**Conversation History:**
${formatConversationHistory(conversationHistory)}

**Criteria for "Significant Change":**
- Structural changes (adding/removing columns, sections, or major reorganization)
- Changes affecting multiple interconnected formulas
- Data migration or moving large amounts of data
- Changes that could break existing calculations
- Ambiguous requests that could be interpreted multiple ways
- Changes requiring understanding of complex business logic

**Simple changes (not significant):**
- Updating individual cell values with clear data
- Minor formatting changes
- Adding single rows of data to existing structure
- Clear, unambiguous single-cell updates

**IMPORTANT:** Respond in the same language as the user's request.

Return ONLY a JSON object:
{
  "isSignificant": true/false,
  "reasoning": "Brief explanation of why this is/isn't significant"
}`;

        try {
            // Check if we need to use cached content
            const useCache = extractedPdfData && extractedPdfData.cacheId && extractedPdfData.processingMode === 'simple_ocr';
            
            const modelName = "gemini-2.5-flash";
            const model = genAI.getGenerativeModel({ model: modelName });
            
            let significanceResult;
            if (useCache) {
                console.log(`[${new Date().toISOString()}] Using cached content for significance analysis: ${extractedPdfData.cacheId}`);
                significanceResult = await genAI.models.generateContent({
                    model: modelName,
                    contents: significancePrompt,
                    config: { cachedContent: extractedPdfData.cacheId }
                });
            } else {
                significanceResult = await model.generateContent(significancePrompt);
            }
            
            const significanceResponse = await significanceResult.response;
            const significanceText = significanceResponse.text();
            
            let significanceAnalysis;
            try {
                const cleanedText = significanceText
                    .replace(/```json/g, '')
                    .replace(/```/g, '')
                    .trim();
                significanceAnalysis = JSON.parse(cleanedText);
            } catch (parseError) {
                console.error('Failed to parse significance analysis, defaulting to significant');
                significanceAnalysis = { isSignificant: true, reasoning: "Failed to parse response, treating as significant for safety" };
            }
            
            console.log(`ğŸ” Significance Analysis:`, significanceAnalysis);
            
            if (!significanceAnalysis.isSignificant) {
                // Simple change - use streamlined logic
                const simpleAgentPrompt = `
You are "Fin-Copilot," an expert Google Sheets agent handling a simple, straightforward change.

**Your Task:**
Generate a JSON object with:
1. "actions": Array of action objects for immediate execution
2. "explanation": Brief summary of what you're doing

**Available Actions:**
- UPDATE: {"type": "UPDATE", "cell": "A1", "value": "new value"}
- CLEAR: {"type": "CLEAR", "cell": "A1"}

**Context:**
${fullContext}

${sheetInstructions ? `**Sheet Guidelines:**
${sheetInstructions}
---
` : ''}

**User Request:** "${question}"

**IMPORTANT:** Respond in the same language as the user's request.

Return JSON with actions to execute immediately.`;

                let simpleResult;
                if (useCache) {
                    simpleResult = await genAI.models.generateContent({
                        model: modelName,
                        contents: simpleAgentPrompt,
                        config: { cachedContent: extractedPdfData.cacheId }
                    });
                } else {
                    simpleResult = await model.generateContent(simpleAgentPrompt);
                }
                
                const simpleResponse = await simpleResult.response;
                const simpleText = simpleResponse.text();
                
                let responseObject;
                try {
                    const cleanedText = simpleText
                        .replace(/```json/g, '')
                        .replace(/```/g, '')
                        .replace(/\n(?!["}])/g, ' ')
                        .replace(/\s*(["\-=+*/(){}[\],:.])\s*/g, '$1')
                        .replace(/\s{2,}/g, ' ')
                        .trim();
                    responseObject = JSON.parse(cleanedText);
                } catch (parseError) {
                    console.error('Failed to parse simple agent response');
                    return res.status(500).send("The AI assistant returned a response in an unexpected format.");
                }
                
                // Execute simple actions immediately
                const { actions, explanation } = responseObject;

                if (actions && Array.isArray(actions) && actions.length > 0) {
                    if (!accessToken || !spreadsheetId) {
                        return res.status(400).send("Cannot execute commands: Missing Access Token or Spreadsheet ID.");
                    }

                    const activeSheet = sheetsMetadata.find(s => s.name === selectedSheetName);
                    if (!activeSheet) {
                        throw new Error(`The AI requested an action for a non-existent sheet: '${selectedSheetName}'`);
                    }
                    const activeSheetId = activeSheet.id;

                    const oauth2Client = new google.auth.OAuth2();
                    oauth2Client.setCredentials({ access_token: accessToken });
                    const sheets = google.sheets({ version: 'v4', auth: oauth2Client });

                    // Take snapshot and execute
                    const cellAddresses = actions.map(action => action.cell);
                    console.log(`ğŸ“¸ Taking snapshot for simple execution: ${cellAddresses.join(', ')}`);
                    
                    const snapshot = await takeSnapshot(cellAddresses, sheets, spreadsheetId, selectedSheetName, activeSheetId);

                    // Build and execute requests
                    let requests = [];
                    console.log(`[SIMPLE] Building ${actions.length} actions`);
                    
                    actions.forEach(action => {
                        const range = {
                            sheetId: activeSheetId,
                            startRowIndex: parseInt(action.cell.match(/\d+/) - 1),
                            endRowIndex: parseInt(action.cell.match(/\d+/) - 1) + 1,
                            startColumnIndex: action.cell.match(/[A-Z]+/)[0].charCodeAt(0) - 'A'.charCodeAt(0),
                            endColumnIndex: action.cell.match(/[A-Z]+/)[0].charCodeAt(0) - 'A'.charCodeAt(0) + 1
                        };

                        switch (action.type) {
                            case 'UPDATE':
                                let userEnteredValue;
                                if (typeof action.value === 'number') {
                                    userEnteredValue = { numberValue: action.value };
                                } else if (typeof action.value === 'string' && action.value.startsWith('=')) {
                                    userEnteredValue = { formulaValue: action.value };
                                } else {
                                    userEnteredValue = { stringValue: action.value };
                                }
                                
                                requests.push({
                                    updateCells: {
                                        rows: [{ values: [{ userEnteredValue: userEnteredValue }] }],
                                        range: range,
                                        fields: "userEnteredValue"
                                    }
                                });
                                requests.push({
                                    repeatCell: {
                                        range: range,
                                        cell: { userEnteredFormat: { backgroundColor: { "red": 0.85, "green": 0.95, "blue": 0.85 } } },
                                        fields: "userEnteredFormat.backgroundColor"
                                    }
                                });
                                break;

                            case 'CLEAR':
                                requests.push({
                                    updateCells: {
                                        range: range,
                                        fields: "*"
                                    }
                                });
                                break;
                        }
                    });

                    // Execute all requests
                    if (requests.length > 0) {
                        await sheets.spreadsheets.batchUpdate({
                            spreadsheetId: spreadsheetId,
                            resource: { requests: requests }
                        });
                    }

                    // Save to action history
                    await ActionHistory.clearRedoHistory(currentSessionId);
                    const actionRecord = new ActionHistory({
                        userId: req.user._id,
                        sessionId: currentSessionId,
                        actionType: 'AI_ACTION',
                        snapshotBefore: snapshot,
                        changeRequest: actions,
                        status: 'EXECUTED',
                        spreadsheetId: spreadsheetId,
                        sheetId: activeSheetId,
                        selectedSheetName: selectedSheetName,
                        changedCells: cellAddresses
                    });
                    await actionRecord.save();

                    console.log(`âœ… Simple execution completed: ${actions.length} actions`);
                }
                
                res.setHeader('Content-Type', 'text/plain; charset=utf-8');
                res.write(explanation || "×”×©×™× ×•×™×™× ×”×¤×©×•×˜×™× ×‘×•×¦×¢×• ×‘×”×¦×œ×—×”");
                res.end();
                return;
            }
            
            // Significant change - create detailed plan
            const planningPrompt = `
You are "Fin-Copilot," an expert financial analyst creating a detailed implementation plan for a complex change to a Google Sheets financial model.

**Your Mission:** Create a comprehensive analysis and ask exactly 5 short clarification questions to ensure perfect execution.

**Context:**
${fullContext}

${sheetInstructions ? `**Sheet Guidelines:**
${sheetInstructions}
---
` : ''}

**User Request:** "${question}"
**Conversation History:**
${formatConversationHistory(conversationHistory)}

**Required Analysis:**
1. **Complexity Assessment:** What makes this change complex?
2. **Data Movement:** What data needs to be moved, copied, or restructured?
3. **Formula Impact:** Which formulas might be affected or broken?
4. **Structural Changes:** What structural changes to the sheet are needed?
5. **Potential Issues:** What could go wrong during implementation?
6. **Ambiguities:** What aspects of the request are unclear or could be interpreted multiple ways?

**Language Detection:** Identify the primary language of the sheet and user request. If PDF is in a different language than the sheet, ask about this.

**Your Task:**
Analyze the specific financial model structure and PDF data to create a detailed INTERNAL execution plan. Break down the sheet editing process into logical steps based on the actual data relationships, formulas, and financial logic. Generate exactly 5 short, specific clarification questions (maximum 10 words each).

**Focus Areas:**
1. **Data Relationships:** How do the PDF values relate to existing sheet structure?
2. **Temporal Logic:** Which years/periods need updating? What about historical vs. projected data?
3. **Formula Dependencies:** Which calculations will be affected by changes?
4. **Structural Impact:** Will tables need to be moved/expanded to avoid overwriting?
5. **Data Validation:** How to ensure consistency between old and new data?

**Example Planning Logic:**
- "Step 1: Move revenue table from B5:F10 to B15:F20 because new quarterly data will overwrite it"
- "Step 2: Update 2024 Q1-Q3 data in cells C5:E5 with PDF values"  
- "Step 3: Extend year columns if PDF contains 2025 data (depends on clarification)"
- "Conditional: If user wants to preserve historical data, copy old values to archive section"
- "Validation: Ensure SUM formulas in row 11 still reference correct ranges after move"

**IMPORTANT:** Respond in the same language as the user's request. All analysis and questions should be in that language.

**Return Format:**
Write a natural text analysis with clear sections. Do NOT use JSON format.

**Structure your response as:**

**COMPLEXITY ANALYSIS:**
[Explain in 2-3 sentences why this change is complex given the specific sheet structure and PDF data]

**EXECUTION PLAN:**
[Write a detailed plan in natural language, organized in numbered steps. Each step should explain what needs to be done, why, and which cells/ranges are affected. Include conditional logic based on clarification answers.]

**POTENTIAL ISSUES:**
[List specific issues that could arise during implementation]

**CLARIFICATION QUESTIONS:**
1. [Short specific question - max 10 words]
2. [Question about specific years/periods - max 10 words]
3. [Question about specific formulas/calculations - max 10 words]
4. [Question about specific layout decisions - max 10 words]
5. [Question about specific validation needs - max 10 words]

**LANGUAGE NOTE:**
[Only if there's mismatch between sheet and PDF languages]`;

            let planningResult;
            if (useCache) {
                planningResult = await genAI.models.generateContent({
                    model: modelName,
                    contents: planningPrompt,
                    config: { cachedContent: extractedPdfData.cacheId }
                });
            } else {
                planningResult = await model.generateContent(planningPrompt);
            }
            
            const planningResponse = await planningResult.response;
            const planningText = planningResponse.text();
            console.log('Planning response:', planningText);
            
            // Extract clarification questions from the text response
            // Try multiple patterns for different languages and formats
            let questionsMatch = planningText.match(/\*\*CLARIFICATION QUESTIONS:\*\*([\s\S]*?)(?:\*\*|$)/);
            if (!questionsMatch) {
                questionsMatch = planningText.match(/###\s*\*\*×©××œ×•×ª ×”×‘×”×¨×”\*\*([\s\S]*?)(?:###|$)/);
            }
            if (!questionsMatch) {
                questionsMatch = planningText.match(/×©××œ×•×ª ×”×‘×”×¨×”([\s\S]*?)(?:###|$)/);
            }
            
            const clarificationQuestions = [];
            
            if (questionsMatch) {
                const questionsText = questionsMatch[1];
                console.log('Questions text found:', questionsText);
                
                // Try different numbering patterns
                let questionMatches = questionsText.match(/^\d+\.\s*(.+)$/gm);
                if (!questionMatches) {
                    // Try Hebrew numbering or bullet points
                    questionMatches = questionsText.match(/^[â€¢\-\*]\s*(.+)$/gm);
                }
                
                if (questionMatches) {
                    questionMatches.forEach(match => {
                        const question = match.replace(/^\d+\.\s*/, '').replace(/^[â€¢\-\*]\s*/, '').trim();
                        if (question && !question.startsWith('[') && question.length > 5) { // Skip placeholder text and very short lines
                            clarificationQuestions.push(question);
                        }
                    });
                }
            }
            
            // If still no questions found, try a more aggressive search
            if (clarificationQuestions.length === 0) {
                console.log('No questions found with structured approach, trying line-by-line search');
                const lines = planningText.split('\n');
                let foundQuestionsSection = false;
                
                for (let line of lines) {
                    line = line.trim();
                    if (line.includes('×©××œ×•×ª ×”×‘×”×¨×”') || line.includes('CLARIFICATION QUESTIONS')) {
                        foundQuestionsSection = true;
                        continue;
                    }
                    
                    if (foundQuestionsSection && line.match(/^\d+\.\s*.+\?/)) {
                        const question = line.replace(/^\d+\.\s*/, '').trim();
                        if (question.length > 10) {
                            clarificationQuestions.push(question);
                        }
                        if (clarificationQuestions.length >= 5) break;
                    }
                }
            }
            
            console.log('Extracted questions:', clarificationQuestions);

            if (clarificationQuestions.length !== 5) {
                console.error('Expected 5 clarification questions, got:', clarificationQuestions.length);
                return res.status(500).send(`×©×’×™××”: ×¦×¤×•×™×•×ª 5 ×©××œ×•×ª ×”×‘×”×¨×”, ×”×ª×§×‘×œ×• ${clarificationQuestions.length}`);
            }

            // Create analysis result object for storage
            const analysisResult = {
                fullAnalysis: planningText,
                clarificationQuestions: clarificationQuestions,
                complexity: planningText.match(/\*\*COMPLEXITY ANALYSIS:\*\*([\s\S]*?)(?:\*\*|$)/)?.[1]?.trim() || '',
                executionPlan: planningText.match(/\*\*EXECUTION PLAN:\*\*([\s\S]*?)(?:\*\*|$)/)?.[1]?.trim() || '',
                potentialIssues: planningText.match(/\*\*POTENTIAL ISSUES:\*\*([\s\S]*?)(?:\*\*|$)/)?.[1]?.trim() || '',
                languageNote: planningText.match(/\*\*LANGUAGE NOTE:\*\*([\s\S]*?)(?:\*\*|$)/)?.[1]?.trim() || ''
            };
            
            // Save the plan to database
            const changePlan = await ChangePlan.createNewPlan(
                req.user._id, 
                currentSessionId, 
                question, 
                analysisResult
            );
            
            console.log(`ğŸ“‹ Created change plan: ${changePlan.planId}`);
            
            // Return ONLY the clarification questions to user (keep analysis internal)
            const clarificationResponse = `
ğŸ” **×”×©×™× ×•×™ ×”××‘×•×§×© ××•×¨×›×‘ ×•×“×•×¨×© ×”×‘×”×¨×•×ª**

×–×™×”×™×ª×™ ×©×”×©×™× ×•×™ ×©×‘×™×§×©×ª ××•×¨×›×‘ ×•×¢×œ×•×œ ×œ×”×©×¤×™×¢ ×¢×œ ××¡×¤×¨ ××–×•×¨×™× ×‘×’×œ×™×•×Ÿ. ×›×“×™ ×œ×‘×¦×¢ ××•×ª×• ×‘×¦×•×¨×” ××“×•×™×§×ª ×•×‘×˜×•×—×”, ×× ×™ ×¦×¨×™×š ×›××” ×”×‘×”×¨×•×ª ×§×¦×¨×•×ª ×××š.

${analysisResult.languageNote ? `
**ğŸŒ ×”×¢×¨×” ×—×©×•×‘×”:**
${analysisResult.languageNote}

` : ''}**ğŸ¤” ×©××œ×•×ª ×”×‘×”×¨×” (×—×•×‘×” ×œ×¢× ×•×ª ×¢×œ ×›×•×œ×Ÿ):**

${analysisResult.clarificationQuestions.map((q, i) => `**${i + 1}.** ${q}`).join('\n\n')}

---

**âš ï¸ ×œ×‘×™×¦×•×¢ ×”×©×™× ×•×™×™×, ×× × ×¢× ×” ×¢×œ ×›×œ 5 ×”×©××œ×•×ª ×œ××¢×œ×”.**

**××–×”×” ×ª×•×›× ×™×ª:** \`${changePlan.planId}\`
`;

            console.log('=== SENDING TO USER ===');
            console.log(clarificationResponse);
            console.log('=== END USER RESPONSE ===');
            
            res.setHeader('Content-Type', 'text/plain; charset=utf-8');
            res.write(clarificationResponse);
            res.end();

        } catch (error) {
            console.error(`[${new Date().toISOString()}] Error in Agent Mode:`, error.response ? error.response.data : error.message);
            res.status(500).send("An error occurred while processing your request in Agent Mode.");
        }

    } else {
        /*********************************/
        /*       CHAT MODE LOGIC         */
        /*********************************/
        // This read-only path remains unchanged and safe.
        console.log(`[${new Date().toISOString()}] Entering Chat Mode (Read-Only).`);
        try {
            // Check if we need cache compatibility
            const useCache = extractedPdfData && extractedPdfData.cacheId && extractedPdfData.processingMode === 'simple_ocr';
            
            // Use consistent model
            const modelName = "gemini-2.5-flash";
            const model = genAI.getGenerativeModel({ model: modelName });
            let contextParts = [];
            let instructionParts = [];
            
            if (sheetData) {
                console.log('ğŸ”¥ Regular chat - Sheet data structure (first 2 rows):', JSON.stringify(sheetData.slice(0, 2), null, 2));
                contextParts.push(`Google Sheet Data:\n${JSON.stringify(sheetData, null, 2)}`);
                instructionParts.push('Google Sheet data');
            }
            if (extractedPdfData) {
                // Check if we have a cached PDF (simple OCR mode) 
                if (extractedPdfData.cacheId && extractedPdfData.processingMode === 'simple_ocr') {
                    console.log(`[${new Date().toISOString()}] Using cached PDF for Chat mode: ${extractedPdfData.cacheId}`);
                    // For cached PDFs, we don't add text to context - the cache handles it
                    instructionParts.push('PDF document (cached)');
                } else {
                    // Traditional mode - add extracted text to context
                    const pdfText = extractedPdfData.extractedText || extractedPdfData;
                    const integrationAnalysis = extractedPdfData.integrationAnalysis;
                    
                    contextParts.push(`PDF Data:\n${pdfText}`);
                    instructionParts.push('PDF data');
                    
                    // Add integration analysis if available
                    if (integrationAnalysis) {
                        contextParts.push(`PDF Integration Analysis:\n${integrationAnalysis}`);
                        instructionParts.push('PDF integration analysis');
                    }
                }
            }
            if (extractedExcelData) {
                contextParts.push(`Excel Data:\n${JSON.stringify(extractedExcelData, null, 2)}`);
                instructionParts.push('Excel data');
            }
            let contextInfo = contextParts.join('\n\n');
            let instructions;
            if (instructionParts.length > 0) {
                const sources = new Intl.ListFormat('en', { style: 'long', type: 'conjunction' }).format(instructionParts);
                instructions = `You have ${sources}. Analyze all available sources to answer the question.`;
            } else {
                contextInfo = 'No data sources available.';
                instructions = 'Answer the question based on your general knowledge, but mention that no specific data was provided.';
            }
            
            // Check if we need to use cached content
            const useCacheForStreaming = extractedPdfData && extractedPdfData.cacheId && extractedPdfData.processingMode === 'simple_ocr';
            
            if (useCacheForStreaming) {
                console.log(`[${new Date().toISOString()}] Using cached content for streaming: ${extractedPdfData.cacheId}`);
                
                const streamingPrompt = `
You are a financial assistant. ${instructions}
The user's question is: "${question}"
Available data:
${contextInfo}
${sheetInstructions ? `

IMPORTANT - Sheet Analysis Context:
A preliminary analysis has been conducted on the current sheet. Here are key insights and guidelines for working with this data:

${sheetInstructions}

` : ''}Please provide a clear, helpful answer in the same language as the question. Do not use JSON format - just respond naturally.

Note: You also have access to a PDF document that was uploaded by the user. Use the PDF content to help answer their question.
`;
                
                // Using cached content with the correct API
                const response = await genAI.models.generateContent({
                    model: modelName,
                    contents: streamingPrompt,
                    config: { cachedContent: extractedPdfData.cacheId }
                });
                
                // Since we can't stream with cache easily, return the full response
                res.setHeader('Content-Type', 'text/plain; charset=utf-8');
                const fullResponse = response.text();
                res.write(fullResponse);
                res.end();
                
                return; // Exit early for cached content
                
            } else {
                const streamingPrompt = `
You are a financial assistant. ${instructions}
The user's question is: "${question}"
Available data:
${contextInfo}
${sheetInstructions ? `

IMPORTANT - Sheet Analysis Context:
A preliminary analysis has been conducted on the current sheet. Here are key insights and guidelines for working with this data:

${sheetInstructions}

` : ''}Please provide a clear, helpful answer in the same language as the question. Do not use JSON format - just respond naturally.
`;
                const result = await model.generateContentStream({
                    contents: [{ role: "user", parts: [{ text: streamingPrompt }] }]
                });
                
                res.setHeader('Content-Type', 'text/plain; charset=utf-8');
                res.setHeader('Transfer-Encoding', 'chunked');
                
                let fullResponse = '';
                for await (const chunk of result.stream) {
                    const chunkText = chunk.text();
                    fullResponse += chunkText;
                    res.write(chunkText);
                }
                
                // ğŸ”¥ DEBUG: Full Gemini response for Chat Stream
                console.log('\nğŸ’¬ === GEMINI CHAT STREAM RESPONSE (FULL) ===');
                console.log(fullResponse);
                console.log('ğŸ’¬ === END CHAT STREAM ===\n');
                
                // Save assistant response only if user is authenticated
                try {
                    if (chatHistory && fullResponse && req.isAuthenticated()) {
                        console.log(`Saving assistant response to session: ${currentSessionId}`);
                        await chatHistory.addMessage('assistant', fullResponse, {
                            isAgentMode: false,
                            hasAttachments: !!(extractedPdfData || extractedExcelData),
                            attachmentTypes: [
                                ...(extractedPdfData ? ['pdf'] : []),
                                ...(extractedExcelData ? ['excel'] : [])
                            ]
                        });
                        console.log(`âœ… Assistant response saved successfully`);
                    }
                } catch (error) {
                    console.error('âŒ Error saving assistant response:', error);
                }
                
                res.end();
            }
        } catch (error) {
            console.error(`[${new Date().toISOString()}] Error during chat streaming:`, error);
            res.end();
        }
    }
});


// Clean up old PDF files every hour
setInterval(() => {
    const now = new Date();
    fs.readdir(uploadsDir, (err, files) => {
        if (err) {
            console.error('Error reading uploads directory:', err);
            return;
        }
        
        files.forEach(file => {
            const filepath = path.join(uploadsDir, file);
            fs.stat(filepath, (err, stats) => {
                if (err) return;
                
                // Delete files older than 48 hours
                const fileAge = now - stats.mtime;
                const maxAge = 48 * 60 * 60 * 1000; // 48 hours in milliseconds
                
                if (fileAge > maxAge) {
                    fs.unlink(filepath, (err) => {
                        if (err) {
                            console.error('Error deleting old file:', err);
                        } else {
                            console.log('Deleted old PDF file:', file);
                        }
                    });
                }
            });
        });
    });
}, 60 * 60 * 1000); // Run every hour

// ğŸ”¥ API Endpoint ×—×“×© ×œ× ×™×ª×•×— ×’×œ×™×•×Ÿ ×¢× Gemini
app.post('/api/analyze-sheet', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ error: 'Not authenticated' });
    }

    const { sheetData, sheetName, analysisType } = req.body;

    if (!sheetData || !sheetName) {
        return res.status(400).json({ error: 'Missing required fields' });
    }

    try {
        const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

        // ğŸ”¥ ×¤×¨×•××¤×˜ ×¨××©×•×Ÿ - ×¡×™×›×•× ×œ×§×•×—
        const summaryPrompt = `
××ª×” ××•××—×” ×¤×™× × ×¡×™ ×•××ª×” ××§×‘×œ ×’×œ×™×•×Ÿ ××§×¡×œ ×œ× ×™×ª×•×—. ×¢×œ×™×š ×œ×¡×¤×§ ×¡×™×›×•× ×§×¦×¨ ×•×‘×”×™×¨ ×œ××©×ª××©.

×©× ×”×’×œ×™×•×Ÿ: ${sheetName}

× ×ª×•× ×™ ×”×’×œ×™×•×Ÿ:
\`\`\`json
${JSON.stringify(sheetData, null, 2)}
\`\`\`

×‘×¦×¢ × ×™×ª×•×— ××”×™×¨ ×•××¡×‘×™×¨ ×œ××©×ª××©:

1. ××” ×¡×•×’ ×”××•×“×œ ×”×¤×™× × ×¡×™ ×”×–×” (×”×¢×¨×›×ª ×©×•×•×™, DCF, × ×™×ª×•×— ×¨×•×•×—×™×•×ª ×•×›×•')
2. ××™×š ×”×’×œ×™×•×Ÿ ×××•×¨×’×Ÿ (×¡×¢×™×¤×™× ×¢×™×§×¨×™×™×, ××™×š ×”× ×ª×•× ×™× ×–×•×¨××™×)
3. ××” ×”××˜×¨×” ×©×œ×• (×œ×—×™×©×•×‘ ××” ×”×•× ××©××©)

×”×ª×—×œ ×‘×“×™×•×§ ×‘××™×œ×™×: "×–×”×• ××•×“×œ" ×•×ª×Ÿ ×ª×©×•×‘×” ×©×œ 2-3 ××©×¤×˜×™× ×‘×œ×‘×“, ×‘×¨×•×¨×™× ×•×§×¦×¨×™×.

×“×•×’××” ×œ×¤×•×¨××˜ ×”×¨×¦×•×™:
"×–×”×• ××•×“×œ ×”×¢×¨×›×ª ×©×•×•×™ DCF ×¢×‘×•×¨ ×—×‘×¨×” ×¦×™×‘×•×¨×™×ª. ×”×’×œ×™×•×Ÿ ××—×•×œ×§ ×œ×ª×—×–×™×•×ª ×”×›× ×¡×•×ª, ×”×•×¦××•×ª ×•×ª×–×¨×™××™ ××–×•×× ×™× ×¢×ª×™×“×™×™×, ×•×‘×¡×•×£ ××—×©×‘ ×©×•×•×™ × ×•×›×—×™ ×•××—×™×¨ ×× ×™×” ××•×¢×¨×š. ×”××˜×¨×” ×”×™× ×œ×”×©×•×•×ª ××ª ×”×©×•×•×™ ×”××—×•×©×‘ ×œ××—×™×¨ ×”× ×•×›×—×™ ×‘×× ×™×” ×›×“×™ ×œ×§×‘×œ ×”×—×œ×˜×ª ×”×©×§×¢×”."`;

        // ğŸ”¥ ×¤×¨×•××¤×˜ ×©× ×™ - ×”×•×¨××•×ª ×œ××¡×™×¡×˜× ×˜
        const instructionsPrompt = `
××ª×” ××•××—×” ×¤×™× × ×¡×™ ×©××›×™×Ÿ ×”×•×¨××•×ª ××¤×•×¨×˜×•×ª ×œ××¡×™×¡×˜× ×˜ AI ×©×™×¢×‘×•×“ ××—×¨ ×›×š ×¢× ×”×’×œ×™×•×Ÿ ×”×–×”.

× ×ª×•× ×™ ×”×’×œ×™×•×Ÿ:
\`\`\`json
${JSON.stringify(sheetData, null, 2)}
\`\`\`

×©× ×”×’×œ×™×•×Ÿ: ${sheetName}

×›×ª×‘ ×”×•×¨××•×ª ×‘×¨×•×¨×•×ª ×¢×‘×•×¨ ××¡×™×¡×˜× ×˜ AI:

**×—×œ×§ ×': ×”×•×¨××•×ª ×¢×“×›×•×Ÿ ×”×’×œ×™×•×Ÿ:**
1. **×ª××™× ××•×ª×¨×™× ×œ×¢×“×›×•×Ÿ:** ××™×–×” ×ª××™× ××›×™×œ×™× × ×ª×•× ×™ ×§×œ×˜ ×©××•×ª×¨ ×œ×©× ×•×ª (×”×›× ×¡×•×ª, ×”×•×¦××•×ª, ×©×™×¢×•×¨×™ ×’×™×“×•×œ ×•×›×•')
2. **×ª××™× ××¡×•×¨×™× ×œ×¢×“×›×•×Ÿ:** ××™×–×” ×ª××™× ××›×™×œ×™× × ×•×¡×—××•×ª ×—×™×©×•×‘ ×©××¡×•×¨ ×œ×’×¢×ª ×‘×”×
3. **×œ×•×’×™×§×ª ×–×¨×™××”:** ××™×š ×”× ×ª×•× ×™× ×–×•×¨××™× ×•××—×•×©×‘×™× ×‘××•×“×œ
4. **×¡×“×¨ ×¢×“×›×•×Ÿ × ×›×•×Ÿ:** ×‘××™×–×” ×¡×“×¨ ×œ×¢×“×›×Ÿ × ×ª×•× ×™× ×›×©××§×‘×œ×™× ×“×•×— ×—×“×©

**×—×œ×§ ×‘': ×”×•×¨××•×ª ×œ×—×™×œ×•×¥ × ×ª×•× ×™× ×-PDF:**
5. **× ×ª×•× ×™× ×—×™×•× ×™×™× ×œ×—×™×œ×•×¥:** ××™×–×” × ×ª×•× ×™× ×¡×¤×¦×™×¤×™×™× ×œ×—×¤×© ×‘×“×•×— ×”×›×¡×¤×™ (×œ××©×œ: ×”×›× ×¡×•×ª ×œ×¤×™ ×¨×‘×¢×•× ×™×, ×¢×œ×•×™×•×ª ××›×¨, ×¨×•×•×— ×ª×¤×¢×•×œ×™, ×ª×–×¨×™× ××–×•×× ×™× ×•×›×•')
6. **××™×›×Ÿ ×œ××¦×•× ×‘×“×•×—:** ××™×¤×” ×‘×“×¨×š ×›×œ×œ ×××•×§××™× ×”× ×ª×•× ×™× ×”×œ×œ×• ×‘×“×•×— ×¨×‘×¢×•× ×™/×©× ×ª×™
7. **××” ×œ× ×œ×—×¤×©:** ××™×–×” × ×ª×•× ×™× ×œ× ×¨×œ×•×•× ×˜×™×™× ××• ×©×œ× ×¦×¨×™×š ×œ×¢×“×›×Ÿ ××•×ª×

×”×ª×—×œ ×‘×“×™×•×§ ×‘××™×œ×™×: "×”×•×¨××•×ª ×¢×‘×•×“×” ×œ××¡×™×¡×˜× ×˜ AI:" ×•×ª×Ÿ ×”×¡×‘×¨ ××•×‘× ×” ×•××¤×•×¨×˜ ×‘×¢×‘×¨×™×ª.

×“×•×’××” ×œ×¤×•×¨××˜ ×¨×¦×•×™:
"×”×•×¨××•×ª ×¢×‘×•×“×” ×œ××¡×™×¡×˜× ×˜ AI:

ğŸ”§ **×¢×“×›×•×Ÿ ×”×’×œ×™×•×Ÿ:**
âœ… ××•×ª×¨ ×œ×¢×“×›×Ÿ: ×ª××™ ×”×›× ×¡×•×ª ×‘×¨×‘×¢×•×Ÿ (A2:A5), ×¢×œ×•×™×•×ª ××›×¨ (B2:B5), ×”×•×¦××•×ª ×©×™×•×•×§ (C2:C5)
âŒ ××¡×•×¨ ×œ×’×¢×ª: × ×•×¡×—××•×ª ×¡×™×›×•× (A6:C6), ×—×™×©×•×‘×™ EBITDA (D2:D10), ×™×—×¡ P/E (E2:E5)
ğŸ”„ ×–×¨×™××”: ×”×›× ×¡×•×ª â†’ ×¢×œ×•×™×•×ª â†’ ×¨×•×•×— ×’×•×œ××™ â†’ ×”×•×¦××•×ª â†’ EBITDA â†’ ×”×™×•×•×Ÿ

ğŸ“Š **×—×™×œ×•×¥ ×-PDF:**
ğŸ¯ × ×ª×•× ×™× ×œ×—×™×œ×•×¥: ×”×›× ×¡×•×ª ×¨×‘×¢×•× ×™×•×ª (×‘×“×´×› ×‘×¢××•×“ 2-3), ×¢×œ×•×™×•×ª ××›×¨ (×“×•×— ×¨×•×•×— ×•×”×¤×¡×“), ×ª×–×¨×™× ××–×•×× ×™× ×—×•×¤×©×™ (×‘×“×•×— ×ª×–×¨×™×), ××¡×¤×¨ ×× ×™×•×ª ×‘××—×–×•×¨
ğŸ“ ××™×§×•× ×‘×“×•×—: ×”×›× ×¡×•×ª - ×“×•×— ×¨×•×•×— ×•×”×¤×¡×“ ×¢×œ×™×•×Ÿ, ×¢×œ×•×™×•×ª - ×××¦×¢ ×”×“×•×—, ×ª×–×¨×™× - ×“×•×— ×ª×–×¨×™× × ×¤×¨×“
ğŸš« ×œ×”×ª×¢×œ× ×: × ×ª×•× ×™× ×”×™×¡×˜×•×¨×™×™× ××¢×‘×¨ ×œ×©× ×ª×™×™×, ×”×¢×¨×•×ª ×©×•×œ×™×™×, × ×ª×•× ×™ ×”×©×•×•××” ×œ××ª×—×¨×™×"`;

        console.log('ğŸ”¥ Analyzing sheet with Gemini:', sheetName);

        // ×©×œ×— ×©× ×™ ×”×¤×¨×•××¤×˜×™× ×œGemini
        const [summaryResult, instructionsResult] = await Promise.all([
            model.generateContent(summaryPrompt),
            model.generateContent(instructionsPrompt)
        ]);

        const summary = await summaryResult.response.text();
        const instructions = await instructionsResult.response.text();

        console.log('ğŸ“Š Sheet analysis completed for:', sheetName);
        console.log('ğŸ“ Summary length:', summary.length, 'characters');
        console.log('ğŸ“‹ Instructions length:', instructions.length, 'characters');
        
        // ğŸ”¥ DEBUG: Full Gemini responses for sheet analysis
        console.log('\nğŸ¯ === GEMINI SUMMARY RESPONSE (FULL) ===');
        console.log(summary);
        console.log('ğŸ¯ === END SUMMARY ===\n');
        
        console.log('\nğŸ“‹ === GEMINI INSTRUCTIONS RESPONSE (FULL) ===');
        console.log(instructions);
        console.log('ğŸ“‹ === END INSTRUCTIONS ===\n');

        res.json({
            summary: summary.trim(),
            instructions: instructions.trim(),
            sheetName: sheetName,
            timestamp: new Date().toISOString()
        });

    } catch (error) {
        console.error('Error analyzing sheet with Gemini:', error);
        res.status(500).json({ 
            error: 'Failed to analyze sheet',
            details: error.message 
        });
    }
});

// New endpoint for executing change plans after clarification
app.post('/api/execute-change-plan', async (req, res) => {
    if (!req.isAuthenticated()) {
        return res.status(401).json({ error: 'Not authenticated' });
    }

    const { planId, clarificationAnswers, spreadsheetId, accessToken, sheetsMetadata, selectedSheetName } = req.body;

    if (!planId || !clarificationAnswers || clarificationAnswers.length !== 5) {
        return res.status(400).json({ error: 'Plan ID and exactly 5 clarification answers are required' });
    }

    try {
        // Find the change plan
        const changePlan = await ChangePlan.findByPlanId(planId);
        if (!changePlan || changePlan.userId.toString() !== req.user._id.toString()) {
            return res.status(404).json({ error: 'Change plan not found' });
        }

        if (changePlan.status !== 'PENDING_CLARIFICATION') {
            return res.status(400).json({ error: 'Change plan is not in pending clarification status' });
        }

        // Update plan with clarification answers
        await ChangePlan.addClarificationAnswers(planId, clarificationAnswers);

        // Generate final execution plan based on clarifications
        const executionPrompt = `
You are "Fin-Copilot" executing a pre-planned complex change to a Google Sheets financial model.

**Original User Request:** "${changePlan.userRequest}"

**Your Previous Analysis:**
- Complexity: ${changePlan.analysisResult.complexity}
- Data Movement: ${changePlan.analysisResult.dataMovement}
- Formula Impact: ${changePlan.analysisResult.formulaImpact}
- Structural Changes: ${changePlan.analysisResult.structuralChanges}
- Potential Issues: ${changePlan.analysisResult.potentialIssues.join(', ')}

**Your Clarification Questions & User Answers:**
${changePlan.analysisResult.clarificationQuestions.map((q, i) => 
  `Q${i + 1}: ${q}\nA${i + 1}: ${clarificationAnswers[i]}`
).join('\n\n')}

**Your Previous Analysis:**
Complexity: ${changePlan.analysisResult.complexity}

**Your Detailed Execution Plan:**
${changePlan.analysisResult.executionPlan}

**Potential Issues Identified:**
${changePlan.analysisResult.potentialIssues}

**Now Execute:** Follow your detailed execution plan above. Use the clarification answers to guide your decisions and execute the appropriate actions based on the user's responses.

**Available Actions:**
- UPDATE: {"type": "UPDATE", "cell": "A1", "value": "new value"}
- CLEAR: {"type": "CLEAR", "cell": "A1"}

**IMPORTANT:** Respond in the same language as the original user request.

**Return Format:**
{
  "actions": [array of action objects],
  "explanation": "Summary of what will be executed based on clarifications",
  "warnings": ["Any final warnings or notes"]
}

Return ONLY the JSON object.`;

        const modelName = "gemini-2.5-flash";
        const model = genAI.getGenerativeModel({ model: modelName });
        
        const executionResult = await model.generateContent(executionPrompt);
        const executionResponse = await executionResult.response;
        const executionText = executionResponse.text();
        
        let finalPlan;
        try {
            const cleanedText = executionText
                .replace(/```json/g, '')
                .replace(/```/g, '')
                .replace(/\n(?!["}])/g, ' ')
                .replace(/\s*(["\-=+*/(){}[\],:.])\s*/g, '$1')
                .replace(/\s{2,}/g, ' ')
                .trim();
            finalPlan = JSON.parse(cleanedText);
        } catch (parseError) {
            console.error('Failed to parse execution plan');
            return res.status(500).send("×©×’×™××” ×‘×™×¦×™×¨×ª ×ª×•×›× ×™×ª ×”×‘×™×¦×•×¢ ×”×¡×•×¤×™×ª.");
        }

        // Save final actions to the plan
        changePlan.finalActions = finalPlan;
        changePlan.status = 'READY_FOR_EXECUTION';
        await changePlan.save();

        // Execute the actions
        const { actions, explanation, warnings } = finalPlan;
        
        if (actions && Array.isArray(actions) && actions.length > 0) {
            if (!accessToken || !spreadsheetId) {
                return res.status(400).send("Cannot execute: Missing Access Token or Spreadsheet ID.");
            }

            const activeSheet = sheetsMetadata.find(s => s.name === selectedSheetName);
            if (!activeSheet) {
                throw new Error(`Sheet not found: '${selectedSheetName}'`);
            }
            const activeSheetId = activeSheet.id;

            const oauth2Client = new google.auth.OAuth2();
            oauth2Client.setCredentials({ access_token: accessToken });
            const sheets = google.sheets({ version: 'v4', auth: oauth2Client });

            // Take snapshot and execute
            const cellAddresses = actions.map(action => action.cell);
            console.log(`ğŸ“¸ Taking snapshot for planned execution: ${cellAddresses.join(', ')}`);
            
            const snapshot = await takeSnapshot(cellAddresses, sheets, spreadsheetId, selectedSheetName, activeSheetId);
            
            // Build and execute requests
            let requests = [];
            console.log(`[PLANNED EXECUTION] Building ${actions.length} actions`);
            
            actions.forEach(action => {
                const range = {
                    sheetId: activeSheetId,
                    startRowIndex: parseInt(action.cell.match(/\d+/) - 1),
                    endRowIndex: parseInt(action.cell.match(/\d+/) - 1) + 1,
                    startColumnIndex: action.cell.match(/[A-Z]+/)[0].charCodeAt(0) - 'A'.charCodeAt(0),
                    endColumnIndex: action.cell.match(/[A-Z]+/)[0].charCodeAt(0) - 'A'.charCodeAt(0) + 1
                };

                switch (action.type) {
                    case 'UPDATE':
                        let userEnteredValue;
                        if (typeof action.value === 'number') {
                            userEnteredValue = { numberValue: action.value };
                        } else if (typeof action.value === 'string' && action.value.startsWith('=')) {
                            userEnteredValue = { formulaValue: action.value };
                        } else {
                            userEnteredValue = { stringValue: action.value };
                        }
                        
                        requests.push({
                            updateCells: {
                                rows: [{ values: [{ userEnteredValue: userEnteredValue }] }],
                                range: range,
                                fields: "userEnteredValue"
                            }
                        });
                        requests.push({
                            repeatCell: {
                                range: range,
                                cell: { userEnteredFormat: { backgroundColor: { "red": 0.85, "green": 0.95, "blue": 0.85 } } },
                                fields: "userEnteredFormat.backgroundColor"
                            }
                        });
                        break;

                    case 'CLEAR':
                        requests.push({
                            updateCells: {
                                range: range,
                                fields: "*"
                            }
                        });
                        break;
                }
            });

            // Execute all requests
            if (requests.length > 0) {
                await sheets.spreadsheets.batchUpdate({
                    spreadsheetId: spreadsheetId,
                    resource: { requests: requests }
                });
            }

            // Save to action history
            const actionHistory = new ActionHistory({
                userId: req.user._id,
                sessionId: changePlan.sessionId,
                snapshotBefore: snapshot,
                changeRequest: finalPlan,
                actionType: 'AI_ACTION',
                status: 'EXECUTED',
                spreadsheetId: spreadsheetId,
                sheetId: activeSheetId,
                selectedSheetName: selectedSheetName,
                changedCells: cellAddresses
            });
            await actionHistory.save();

            // Update plan status
            changePlan.status = 'EXECUTED';
            await changePlan.save();

            console.log(`âœ… Planned execution completed: ${actions.length} actions`);
        }

        const finalResponse = `
âœ… **×ª×•×›× ×™×ª ×‘×•×¦×¢×” ×‘×”×¦×œ×—×”!**

**××” ×‘×•×¦×¢:** ${explanation}

${warnings && warnings.length > 0 ? `
**âš ï¸ ×”×¢×¨×•×ª ×—×©×•×‘×•×ª:**
${warnings.map(w => `â€¢ ${w}`).join('\n')}
` : ''}

**ğŸ“Š ×¡×™×›×•×:** ${actions ? actions.length : 0} ×¤×¢×•×œ×•×ª ×‘×•×¦×¢×• ×‘×’×œ×™×•×Ÿ.

**××–×”×” ×ª×•×›× ×™×ª:** \`${planId}\` (×”×•×©×œ××”)
`;

        res.setHeader('Content-Type', 'text/plain; charset=utf-8');
        res.write(finalResponse);
        res.end();

    } catch (error) {
        console.error('Error executing change plan:', error);
        res.status(500).send("×©×’×™××” ×‘×‘×™×¦×•×¢ ×”×ª×•×›× ×™×ª. ×× × × ×¡×” ×©×•×‘.");
    }
});

app.listen(PORT, () => {
    console.log('ğŸš€ Login & Extraction server running on http://localhost:' + PORT);
    console.log('ğŸ“± Frontend should be running on http://localhost:3000');
});
